[functions]
	[function]
	args="level,n"
	name="score"
	formula="set(level.player.vars.score, level.player.vars.score + n)"
	[/function]
	
	
	[function]
	args="level"
	name="kc"
	formula="[set(level.player.driver.max_hitpoints, 10), set(level.player.driver.hitpoints, 10), 
		set(level.player.driver.spit_power, 160), set(level.player.driver.tongue_length, 22),
		set(level.player.driver.unlocked_items, level.player.driver.unlocked_items + ['powerup_invincible'] + ['powerup_shooting'] + ['powerup_reflexes'])]"
	[/function]

	[function]
	args="level,n"
	name="gold"
	formula="[if(level.player.driver.coins + n >= 10, achievement('pocket_money')),
	add(level.player.driver.coins, n),add(level.player.vars.gold_counter, n),
	set(level.player.vars.last_got_gold, level.player.cycle),
	fire_event(level.player,'display_gold')]"
	[/function]

	[function]
	args="parent*"
	name="spawn_item"
	formula="if(level.player.vars.next_unlocked_item, [spawn(level.player.vars.next_unlocked_item, parent.midpoint_x, parent.y, parent.facing), set(level.player.vars.next_unlocked_item, null())],
	         if(unlocked_items, spawn( choose(unlocked_items, 1d1000) , parent.midpoint_x, parent.y, parent.facing, [set(velocity_x, velocity_x/6 +1d600-300), set(velocity_y, velocity_y/6)])))

	where unlocked_items = filter(if(level.player.vehicle, level.player.vehicle.vars.unlocked_items, level.player.vars.unlocked_items), 'item', if(level.player.hitpoints = level.player.max_hitpoints and item = 'heart_object' or level.player.vars.powerup_time > 0 and strstr(item, 'powerup'), 0, 1))"

	#  if we want vehicle items AND player items when you're in a vehicle, then do the following:
	#where unlocked_items = if(level.player.vehicle, level.player.vehicle.vars.unlocked_items + level.player.driver.vars.unlocked_items, level.player.vars.unlocked_items) "
	[/function]


	[function] #physics-functions
	name="elastic_collision"
	args="a,b"
	#takes two objects as parameters, changes their velocities according to an elastic collision
	# note deep magic on if(a < b) - this compares the memory addresses, and is done to ensure collisions aren't calculated twice (once on each end of the collision).


	#formula=" [set(a, 'velocity_x', -1200 ), set(b, 'velocity_x', 1200) ]  "
#	formula=" [set(a, 'velocity_x', (a.velocity_x*1000 * (a.mass - b.mass)/(a.mass + b.mass) + (b.velocity_x*1000 * b.mass)/ (a.mass + b.mass))/1000 ), set(b, 'velocity_x', ((a.mass * a.velocity_x*1000)/(a.mass + b.mass) + b.velocity_x*1000 * (b.mass - a.mass )/(a.mass + b.mass))/10 ) ]"

	formula="if(a.mass and b.mass, [set(a.velocity_x, (momentum_x/2)/a.mass),
	          set(b.velocity_x, (momentum_x/2)/b.mass)]
			  where momentum_x = a.velocity_x*a.mass + b.velocity_x*b.mass)"
	
	[/function]
	
	#function groups:
	@include "data/geometry-functions.cfg"
	@include "data/time-functions.cfg"
	
	
[/functions]
