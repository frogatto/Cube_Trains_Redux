[
	#three functions to help with powerup testing
	{
		args: "level",
		name: "shooting",
		formula: "set(level.player.driver.unlocked_items, ['powerup_shooting', 'points_cube'])",
	},
	{
		args: "level",
		name: "invincible",
		formula: "set(level.player.driver.unlocked_items, ['powerup_invincible', 'points_cube'])",
	},
	{
		args: "level",
		name: "reflexes",
		formula: "set(level.player.driver.unlocked_items, ['powerup_reflexes', 'points_cube'])",
	},
	
	{
		args: "level,n",
		name: "score",
		formula: "set(level.player.vars.score, level.player.vars.score + n)",
	},
	{
		args: "level,n",
		name: "gold",
		formula: "[
			if(level.player.driver.coins + n >= 10, achievement('pocket_money')),
			#We give a little leeway to the players; the actual maximum is 1059 coins (frogatto 1.1)#
			if(level.player.driver.coins + n >= 1048, achievement('gold_hoarder')),
			if(level.player.driver.coins + n >= 99999,
				[achievement('speed_trader'),
				set(level.player.driver.coins, 99999),
				set(level.player.vars.gold_counter, 99999-level.player.driver.coins)],
				[add(level.player.driver.coins, n),
				add(level.player.vars.gold_counter, n)]
			),
			set(level.player.vars.last_got_gold, level.player.cycle),
			fire_event(level.player,'display_gold')]",
	},
	{
		args: "parent*",
		name: "spawn_item",
		formula: "if(level.player.vars.next_unlocked_item, [spawn(level.player.vars.next_unlocked_item, parent.midpoint_x, parent.y, parent.facing), set(level.player.vars.next_unlocked_item, null)],
			if(unlocked_items, spawn( choose(unlocked_items, 1d1000) , parent.midpoint_x, parent.y, parent.facing, [set(velocity_x, velocity_x/6 +1d600-300), set(velocity_y, velocity_y/6)])))
			where unlocked_items = filter(if(level.player.vehicle, level.player.vehicle.vars.unlocked_items, level.player.vars.unlocked_items), 'item', if(level.player.hitpoints = level.player.max_hitpoints and item = 'heart_object' or level.player.vars.powerup_time > 0 and strstr(item, 'powerup'), 0, 1))",
	},

	#  if we want vehicle items AND player items when you're in a vehicle, then do the following:
	#where unlocked_items = if(level.player.vehicle, level.player.vehicle.vars.unlocked_items + level.player.driver.vars.unlocked_items, level.player.vars.unlocked_items) "
	{
		name: "register_kill",
		args: "obj",
		formula: "[
			[if(time() - kc[size(kc)-4][1] < 10, achievement('rampage')),
			if(kc[15][0].type = kc[14][0].type and
			kc[15][0].type = kc[13][0].type and
			kc[15][0].type = kc[12][0].type and
			kc[15][0].type = kc[11][0].type and
			kc[15][0].type = kc[10][0].type and
			kc[15][0].type = kc[9][0].type and
			kc[15][0].type = kc[8][0].type and
			kc[15][0].type = kc[7][0].type and
			kc[15][0].type = kc[6][0].type and
			kc[15][0].type = obj.type, achievement('grudge'))]where kc = obj.level.player.vars.achievement_kill_chain,
			set(obj.level.player.vars.achievement_kill_chain, slice(obj.level.player.vars.achievement_kill_chain, 1, 16) + [[obj, time()]])
			]",
	},
	
	{
		name: "splash_effect",
		args: "obj",
		formula: "if(obj.underwater,
				[if(abs(obj.water_bounds[1] - obj.midpoint_y) > 40,
					spawn('water_splash_underwater_big', obj.midpoint_x, obj.midpoint_y, if(1d2=2,obj.facing,-obj.facing)),
					spawn('water_splash', obj.midpoint_x, obj.water_bounds[1]+10, if(1d2=2,obj.facing,-obj.facing))),
				sound('water-enter.ogg'), ])",
	},
	
	{
		name: "death_burst",
		args: "obj",
		formula: "[if(obj.underwater,
			splash_effect(obj),
			spawn('die_cloud', obj.midpoint_x, obj.midpoint_y, obj.facing))]",
	},
	{

		#wrapped version of death_burst that tracks death for achievements
		name: "death_burst_tracked",
		args: "obj",
		formula: "[death_burst(obj),register_kill(obj)]",
	},
	
	{
		name: "impact_cloud_silent",
		args: "new_x,new_y,size",
		formula: "if(size = 'small', spawn('impact_cloud_small',new_x,new_y,1), spawn('impact_cloud',new_x,new_y,1))",
	},
	{
		name: "impact_cloud",
		args: "new_x,new_y,size",
		formula: "[impact_cloud_silent(new_x,new_y,size),sound('bump-2.wav')]",
	},
	
	{
		name: "elastic_collision",
		args: "a,b",

		#takes two objects as parameters, changes their velocities according to an elastic collision
		# note deep magic on if(a < b) - this compares the memory addresses, and is done to ensure collisions aren't calculated twice (once on each end of the collision).
		formula: "if(a.mass and b.mass, [
				set(a.velocity_x, (momentum_x/2)/a.mass),
				set(b.velocity_x, (momentum_x/2)/b.mass),
				] where momentum_x = a.velocity_x*a.mass + b.velocity_x*b.mass)",
	},
	
	{
		name: "send_to_coordinates",
		args: "obj,gotx,goty,vel",
		formula: "[
			set(obj.velocity_x,cos(angle(obj.midpoint_x,obj.midpoint_y,gotx,goty))*vel),
			set(obj.velocity_y,sin(angle(obj.midpoint_x,obj.midpoint_y,gotx,goty))*vel)]",
	},
	{
		name: "set_relative_velocity",
		args: "obj, vel",
		formula: "send_to_coordinates(obj,rotx,roty,vel)
			where rotx = ((obj.midpoint_y+1)*sin(-obj.rotate) + obj.midpoint_x)
			where roty = ((obj.midpoint_y+1)*cos(-obj.rotate) + obj.midpoint_y)",
	},
	
	{
		name: "obj_strs",
		args: "obj",
		formula: "'(object {obj.label}: type={obj.type}, pos=[{obj.midpoint_x},{obj.midpoint_y}], animation={obj.animation}, cycle={obj.cycle}, active={obj.active})'",
	},

	"@flatten",
	"@include data/functions-math.cfg",
	"@include data/functions-time.cfg",
	"@include data/functions-geometry.cfg",
	"@include data/functions-list.cfg",
	
	{

		#list:	A list of something to be added into sum.
		#sum:	An empty member of a type which is addition-compatible with all members of the list.
		name: "flex_sum",
		args: "list, sum",
		formula: "if(size(list), flex_sum(list[1:size(list)], sum+list[0]) ,sum)",
	},
	
	{
		name: "map_merge",
		args: "map1, map2",
		formula: "flex_sum(
			map(keys(map1) + filter(keys(map2), 'existing_key', not existing_key in keys(map1)), 'key',
				{(key) -> if(map1[key] and map2[key], map1[key] + map2[key],
					if(map1[key],
						map1[key],
						map2[key])
					)}
				), {})",
	},

	#each element in data overwrites each element in list, starting with the element at index. If index is out of bounds or the data does not fit in the list, Bad Stuff Happensâ„¢.
	#eg., args [1,2,3,4,5], 2, ['a', 'b'] would return [1,2,'a','b',5].
	{
		name: "list_replace_elements",
		args: "list, index, data",
		formula: "list[0:index] + data + list[index+size(data):size(list)]",
	},
	{
		name: "list_get_random",
		args: "list",
		formula: "list[(1 d size(list)) - 1]",
	},
	{
		name: "_list_cat",
		args: "list, sum, delim",
		formula: "if(size(list) > 0, _list_cat(list[1:size(list)], if(sum = '', str(list[0]), sum + str(list[0])) + if(size(list) > 1, delim, ''), delim), sum)",
	},
	{
		name: "list_cat",
		args: "list",
		formula: "_list_cat(list, '', '')",
	},
	{
		name: "list_cat_delim",
		args: "list, delim",
		formula: "_list_cat(list, '', delim)",
	},
	{
		name: "join",
		args: "list",
		formula: "list_cat(list)",
	},
	{
		name: "join_d",
		args: "list, delim",
		formula: "list_cat_delim(list, delim)",
	},
	{
		#Given a list and an index, return [the object at that index, the rest of the list without that object]
		name: "list_pop",
		args: "list, index",
		formula: "[list[index], list[0:index] + list[index+1:size(list)]]",
	},
	{
		name: "best_between",
		args: "list1, list2, criteria",
		formula: "transform(range(size(list1)), if(criteria(list1[v], list2[v]), list1[v], list2[v]))",
	},
	{
		name: "best_of",
		args: "lists, criteria",
		formula: "switch(size(lists), 
			0, [],
			1, lists[0],
			2, best_between(lists[0], lists[1], criteria),
			best_between(lists[0], best_of(lists[1:size(lists)], criteria), criteria))",
	},
	{
		name: "_zip",
		args: "list1, list2",
		formula: "transform(range(size(list1)), [list1[v]] + if(is_list(list2[v]), list2[v], [list2[v]]))",
	},
	{
		name: "zip",
		args: "lists",
		formula: "switch(size(lists), 
			0, [],
			1, lists[0],
			2, _zip(lists[0], lists[1]),
			_zip(lists[0], zip(lists[1:size(lists)])))",
	},
	{
		name: "_zip_with",
		args: "list1, list2, criteria",
		formula: "transform(range(size(list1)), criteria(list1[v], list2[v]))",
	},
	{
		name: "zip_with",
		args: "lists, criteria",
		formula: "switch(size(lists),
			0, [],
			1, lists[0],
			2, _zip_with(lists[0], lists[1], criteria),
			_zip_with(lists[0], zip_with(lists[1:size(lists)], criteria), criteria))",
	},
	{
		#list - a list of stuff to apply a function to, and so collapse to one value.
		#method - the /property/, taking two args, with which to collapse the list. Must be a property as defined by def(). The things in this file are functions, and will not work. However, they may be called from properties.
		#Reduces list by calling /method/ with the first arg being the first element of the list and the second arg being the reduction of the rest of the list or the last element.
		#/method/ doesn't need to check for the end of the list. It just specifies how to combine any two elements into one.
		#For example, method = "def(u,v) u+v" would make list_reduce behave equivalent to sum(list), albeit slower.
		name: "list_reduce",
		args: "list, method",
		formula: "if(size(list) > 0, if(size(list) > 1, method(list[0], list_reduce(list[1:size(list)], method)), list[0]))",
	},
    {
        name: "foldr",
        args: "f,z,x",
        formula: "if(size(x)=0,z,f(x.first,foldr(f,z,x[1:])))",
    },
    
	{
		name: "head",
		args: "list",
		formula: "if(size(list), list[0])",
	},
	{
		name: "tail",
		args: "list",
		formula: "if(size(list), list[1:size(list)], [])",
	},
	{
		name: "last",
		args: "list",
		formula: "if(size(list), list[size(list)-1])",
	},
	
	{
		name: "unique",
		args: "list",
		formula: "filter(items, index = size(items)-1 or items[index] != items[index+1]) where items = sort(list)",
	},
	
	{
		name: "find_index", #doesn't work
		args: "list, target, index",
		formula: "debug_fn('WARNING: find_index is deprecated.', if(list[index] = target, index, find_index(list, target, index+1)))",
	},
	
	{
		name: "dump",
		args: "toDump",
		formula: "debug_fn(toDump, toDump)",
	},
	{
		name: "dump2",
		args: "id, toDump",
		formula: "if(not id, 
			debug_fn(toDump, toDump),
			debug_fn([id, toDump], toDump))",
	},
	
	{
		name: "set_mid",
		args: "obj, point",
		formula: "if(is_list(point),
			[set(obj.midpoint_x, point[0]), set(obj.midpoint_y, point[1])],
			[set(obj.midpoint_x, point.midpoint_x), set(obj.midpoint_y, point.midpoint_y)])",
	},
	{
		name: "get_mid",
		args: "obj",
		formula: "[obj.midpoint_x, obj.midpoint_y]",
	},
	
    {
		// left folding algorithm.
		// f -- function to apply, this must be a first-class function, so currently only lambda functions need apply.
		// z -- initial value
		// x -- list to apply the function f to.
		// Examples.
		// inclusive logical or the values in a list of booleans together: 
		//  foldl(def(a,b) a or b, false, [false,false,false,false,false,false,true]) 
		//    --> true
		// Convert a list of maps each having an attribute called id and unqiue values into a map of maps, referenced by id.
		// foldl(def(a,b) a + {b.id:b}, {}, [{id:'a', x:0, y:1}, {id:'b', u:3, v:4}, {id:'c', r:5, s:6}])
		//    --> {'a':{id:'a', x:0, y:1}, 'b':{id:'b', u:3, v:4}, 'c':{id:'c', r:5, s:6}}
        name: "foldl",
        args: "f,z,x",
        formula: "if(size(x)=0,z,foldl(f,f(z,x.first),x[1:]))",
    },
	
	{
		/*
		Args: function, list A, list B, integer or list C
			function: A function to be executed in the context of the current object, taking a list as it's only arg.
				(This will be evaluated on the current frame, but applied over subsequent frames.)
			list A: The initial value to be passed to the function.
			list B: The last value to be passed to the function. Must be same length as list A.
			integer: The number of interpolated frames between list A and list B.
				(The rate of execution is one value/frame.)
			list C: The list produced by range(10) is exactly equivalent to an integer of 10 in this slot.
				(This can give you finer control of the scheduling.)
		Example: scheduled_animation(def(val) [set(self.x, val[0]), set(self.y, val[1])], [5,10], [45,100], 50)
		*/
		name: "scheduled_animation",
		args: "setter, from, to, steps",
		formula: "transform(stepsList, 
			schedule(v, setter(
				list_tween(from, to, 1-decimal(v)/last(stepsList))
				))
			) where stepsList = if(is_list(steps), steps, range(steps))"
	},
	
	{
		name: "newln",
		args: "number",
		formula: "list_cat(transform(range(number), '\n'))",
	},
]
