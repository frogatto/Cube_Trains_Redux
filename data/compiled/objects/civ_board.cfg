[object_type]
hitpoints="2"
id="civ_board"
no_compile_image="experimental/civ-tile.png"
on_ai_die_turn="[
		if(size(validity2d) > 0, [
			set(tile_to_place[0].midpoint_x, tile_at(validity2d[eY][eX])[0]), #set tile pos to grid we chose#
			set(tile_to_place[0].midpoint_y, tile_at(validity2d[eY][eX])[1]),
			set(tile_to_place[0].animation, consts.tile_types[vars.turn]), #set the animation to the current side#
			fire_event('tiles_in_play_modified'),	#update the tile cache#
			set(tile_to_place[0].vars.gridloc, validity2d[eY][eX]), #set the grid location of the tile#
			set(vars.play, vars.play+[tile_to_place[0]]), #add the tile to the list of tiles in play#
			add_object(tile_to_place[0]),
			tile_to_place[1], #actually remove the object from it's bag#
			] where eX = (1d (size(validity2d[eY])))-1 #eX and eY are now valid locations coordinates.#
			where eY = (1d (size(validity2d)))-1,
			fire_event('ai_die_turn'),
			)
		where validity2d = filter(
			map(range(consts.tiles), 'cX', 
				filter(
					map(range(consts.tiles), 'cY', 
						if(is_valid_addition(tile,[cX, cY])
						and (not [cX, cY] in map(vars.play, 'tile', tile.vars.gridloc)
						and ((not find(starve(tile, [cX, cY]), 'dead', dead.animation = tile.animation))
						  or tile.search_adjacent_connected_to_farm(tile_at([cX, cY])[0], tile_at([cX, cY])[1], consts.tile_types[vars.turn])))
						and has_food(tile, [cX, cY]), 
							[cX,cY]
							)
						), 
					'add', add != null)
				),
			'add', add != [])
		where tile = tile_to_place[0],
		
		#debug('ended die`s turn'),# fire_event('end_turn'),
		] where tile_to_place = vars.bag.extract(vars.turn)"
on_create="[
		set(draw_area, [0, 0, board_size(), board_size()]),
		set(vars.camera_pos, level.camera_position),
		[set(new_bag.vars.spawner, self),
		add_object(new_bag),
		set(vars.bag, new_bag),
		]where new_bag = object('civ-tile_bag', x + board_size()*2 + right_column_offset, y+((board_size()*5)/3), facing),
		
		if(size(consts.land) = consts.tiles*consts.tiles,
			map(range(size(consts.land)), 'land_index', spawn(self.type + '.' + ltype, lcoord[0], lcoord[1], facing) where lcoord = tile_at([land_index%consts.tiles, land_index/consts.tiles]) where ltype = switch(consts.land[land_index], 0, 'ocean_grid', 1, 'plain_grid', 2, 'hill_grid', 3, 'ore_grid', 'ocean_grid')),
			debug(size(consts.land), ' does not equal ', consts.tiles*consts.tiles, ', failed creating map tiles from land data.')),
			
		spawn('civ_logo', x + board_size()*2 + right_column_offset, y+((board_size()*2)/4), facing),
		
		if(consts.players[0] != 'human' ,[set(vars.turn, -1), fire_event('end_turn')]),
		
		schedule(3, fire_event('find_buttons')),
		
		[set(vars.help_obj, help_obj),
		help_obj.set_text(~Drag a tile to the board to play. Right-click for help.~),
		add_object(help_obj),
		] where help_obj = object('text_controller',help_text_pos[0],help_text_pos[1],0)
		
		] where right_column_offset = 125
		where camera = get_object(level, 'logic')"
on_end_anim="animation('normal')"
on_end_turn="[[schedule(25, [
		switch(consts.players[nt],
		'human', [],
		'ai_die', [fire_event('ai_die_turn')],
		debug('Illegal side', nt),
		),
		#debug(str(tile.animation) + ' ' + str(tile.type) + ' at ' + str(tile.vars.gridloc)) where tile = vars.play[size(vars.play)-1],#
		]),
		set(vars.turn, nt),
		] where nt = (vars.turn+1)%size(consts.players),
		map(vars.play, 'tile', 
			if(not (has_food(tile, tile.vars.gridloc) or tile.type = 'civ-tile_farm'), [
				set(vars.play, filter(vars.play, 'in_play', in_play != tile)), 
				fire_event(tile, 'nix'), 
				[add_object(starve_obj), 
				set(starve_obj.midpoint_x, tile.midpoint_x), 
				set(starve_obj.midpoint_y, tile.midpoint_y)
				] where starve_obj = object('civ_starve', x, y, facing), 
				fire_event('tiles_in_play_modified')
				])
			),
		]"
on_fail_release_tile="if((not on_piece(mouse).animation != arg.animation) or arg.type != 'civ-tile_war' or (not on_any_tile(mouse)), 
			fire_event('rehand_tile', arg),
			if(is_valid_addition(arg, mouse_on_tile()), #WAR!#
				[#set(arg.midpoint_x, mouse[0]),
				set(arg.midpoint_y, mouse[1]),#
				bag.turn_button.set_state('replace'),
				
				fire_event('war', arg),
				#war_defeat_tile(on_piece(mouse)),#
				fire_event('release_tile_internal', arg),
				
				], 
				fire_event('rehand_tile', arg),)
			)"
on_fight="map(range(size(actions)), 'index', schedule(index * 10, actions[index]))
		where actions = if(size(recruited) > 0, map(range(size(recruited)), 'rind', [
			map(range(res), 'delay', schedule(delay, [
				set(recruited[rind].x, (recruited[rind].x*(res-delay) + war_arg.x*delay)/res),
				set(recruited[rind].y, (recruited[rind].y*(res-delay) + war_arg.y*delay)/res)])) where res = 20,
			schedule(21, fire_event(recruited[rind], 'nix'))
			]))
		+ [schedule(if(size(recruited) > 0, 15, 0), [ #finish the fight#
		set(vars.war, 0),
		set(vars.help_obj.x, vars.help_obj.x + 220),
		set(level.lock_screen, [vars.camera_pos[0]+vars.camera_pos[2]/2,vars.camera_pos[1]+vars.camera_pos[3]/2]),
		set(vars.war_arg.zorder, arg.zorder - 1),
		if(strengths[0]+ai_die_war(vars.war_on.vars.gridloc) >= strengths[1]+size(recruited), 
			[war_defeat_tile(vars.war_arg),
			help(tile_side_name(vars.war_arg) + ~'s warriors have fled! (~ + str(strengths[0]+ai_die_war(vars.war_on.vars.gridloc)) + ~ to ~ + str(strengths[1]+size(recruited)) + ~)~),
			],
			[war_defeat_tile(vars.war_on), 
			add_tile(vars.war_arg, on_any_tile([vars.war_arg.midpoint_x,vars.war_arg.midpoint_y])),
			help(~A ~ + tile_side_name(vars.war_on) + ' ' + tile_name(vars.war_on) + ~ was destroyed by ~ + tile_side_name(vars.war_arg) + ~'s warriors! (~ + str(strengths[0]+ai_die_war(vars.war_on.vars.gridloc)) + ~ to ~ + str(strengths[1]+size(recruited)) + ~)~),
			]),
			set(vars.bag.vars.on_deal_tile, vars.war_arg.vars.hand_pos),
			fire_event(vars.bag, 'deal_p1'),
			set(recruited, []),
			set(not_refilled_when_played, recruited),
			#debug(recruited),#
			if(size(vars.bag.vars.piles[vars.turn]) = 1, debug('Game Over'), fire_event('end_turn')),
		])]"
on_find_buttons="[set(vars.turn_button, bag.turn_button), set(vars.fight_button, get_object(level, 'fight')), set(get_object(level, 'fight').board, self)]"
on_lmb_down="[
		fire_event(vars.turn_button, 'lmb_hold', level.player.vars.mouse),
		fire_event(vars.fight_button, 'lmb_hold', level.player.vars.mouse),
		if(not war, [
		map(vars.hand, 'tile', fire_event(tile, 'lmb_down', level.player.vars.mouse)),
		],
		map(vars.hand, 'tile', fire_event(tile, 'war_select', level.player.vars.mouse)),
		)]"
on_lmb_hold="if(not war, [
		#debug('tile:', mouse_on_tile())#
		if(ot,
			[set(tmp.old_ot, ot),
			if(tmp.old_ot != ot,
				[set(tmp.tile_highlight, hlt),
				add_object(hlt),
				remove_object(tmp.tile_highlight),
				]where hlt = object('civ_board.tile', tile_at(ot)[0], tile_at(ot)[1], facing)
				)
			],
			[set(tmp.old_ot, 0),
			remove_object(tmp.tile_highlight),
			])
		where ot = mouse_on_tile(),
		
		fire_event(vars.turn_button, 'lmb_hold', level.player.vars.mouse),
		fire_event(vars.fight_button, 'lmb_hold', level.player.vars.mouse),
		])"
on_lmb_up="[
		remove_object(tmp.tile_highlight),
		fire_event(vars.turn_button, 'lmb_up', level.player.vars.mouse),
		fire_event(vars.fight_button, 'lmb_up', level.player.vars.mouse),
		]"
on_make_blink="[set(arg.alpha, 0), schedule(20, [set(arg.alpha, 256), schedule(20, if(vars.war, fire_event('make_blink', arg)))])]"
on_refresh_warrior_selected_text="get_object(level, 'strength').set_text(~Armies:~ + '\n' + str(strengths[0]) + ~(+?) VS ~ + str(strengths[1]) + ~(+~ + str(size(recruited)) + ~)~)"
on_rehand_tile="arg.go_to(dealt_hand_loc(0,arg.vars.hand_pos))"
on_release_tile="if(mouse_on_tile() and consts.players[vars.turn] = 'human',
		[set(arg.midpoint_x, tile_at(mouse_on_tile())[0]),
		 set(arg.midpoint_y, tile_at(mouse_on_tile())[1]),
	     fire_event('release_tile_internal', arg)],
	     fire_event('fail_release_tile', arg))"
on_release_tile_internal="if(not vars.war,
	    [#debug(tile_at(mouse_on_tile())),#
		if(mot and is_valid_addition(arg, mouse_on_tile()) and (not arg.type = 'civ-tile_war' and (played(mouse_on_tile()))), #add a tile normally#
			[set(arg.vars.gridloc, mot),
			set(arg.midpoint_x, tile_at(mot)[0]), 
			set(arg.midpoint_y, tile_at(mot)[1]), 
			set(vars.play, vars.play + [arg]), #the crashy bit - Setting arg.midpoint_s before this function avoids a [] crash. Why?#
			fire_event('tiles_in_play_modified'),
			set(vars.bag.vars.on_deal_tile, arg.vars.hand_pos),
			set(arg.animation, consts.tile_types[vars.turn]),
			fire_event(vars.bag, 'deal_p1'),
			if(size(vars.bag.vars.piles[vars.turn]) = 1, debug('Game Over'), fire_event('end_turn')),
			],
			fire_event('fail_release_tile', arg))
			where mot = mouse_on_tile(),
		])"
on_replace="[
		#set(vars.mode, 'replace'),#
		#debug_console(),#
		map(range(size(not_refilled_when_played)), 'ind', schedule(ind*4, [
			set(vars.bag.vars.on_deal_tile, not_refilled_when_played[ind].vars.hand_pos),
			fire_event(vars.bag, 'deal_p1'),])),
		schedule(29, fire_event('end_turn')),
		]"
on_rmb_down="[
		map(vars.hand, 'tile', if(help_txt, help(help_txt)) where help_txt = tile.help(level.player.vars.mouse)),
		]"
on_tiles_in_play_modified="[add(vars.cache_version, 1),
	     map(vars.play, 'p', fire_event(p, 'calculate_surroundings')),
	     map(vars.play, 'p', fire_event(p, 'calculate_kingdom', context))]"
on_war="[ #set up the war#
		set(vars.war, 1),
		set(vars.help_obj.x, vars.help_obj.x - 220),
		help('Select additional warrior tiles from hand for one-time use.'),
		set(level.lock_screen, [vars.camera_pos[0]+vars.camera_pos[2]/2-220,vars.camera_pos[1]+vars.camera_pos[3]/2]),
		set(arg.zorder, arg.zorder + 1), #doesn't work#
		fire_event('make_blink', on_piece(mouse)),
		schedule(20, fire_event('make_blink', arg)),
		get_object(level, 'vs').set_text(tile_side_name(on_piece(mouse)) + ~ VS ~ + tile_side_name(arg.animation)),
		get_object(level, 'strength').set_text(~Armies:~ + '\n' + str(strengths[0]) + ~(+?) VS ~ + str(strengths[1]) + ~(+0)~),
		set(vars.strengths, strengths),
		set(vars.war_arg, arg), set(vars.war_on, on_piece(mouse)),
		#war_defeat_tile(on_piece(mouse)),#
		] where strengths = [size(filter(k_group(mouse, on_piece(mouse).animation), 'tile', tile.type = 'civ-tile_war')), size(filter(k_group(mouse, arg.animation), 'tile', tile.type = 'civ-tile_war'))+1]"
zorder="-11"
	[consts]
	land="[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,3,0,1,1,0,0,0,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,0,1,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,1,1,1,1,2,2,2,1,1,0,0,0,0,0,1,1,1,2,3,2,2,1,1,1,0,0,0,0,0,1,2,2,2,2,2,0,0,0,0,0,0,1,1,1,1,2,2,3,2,2,0,0,0,0,0,0,1,1,0,0,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,]"
	players="['ai_die', 'ai_die', 'human', 'ai_die']"
	tile_size="16"
	tile_types="['normal', 'gold', 'black', 'silver']"
	tiles="14"
	[/consts]

	[vars]
	cache_version="0"
	camera_pos="[0,0,0,0]"
	hand="[]"
	hand_size="6"
	help_text_pos="[50, 575]"
	not_refilled_when_played="[]"
	play="[]"
	recruited="[]"
	turn="0"
	[/vars]

	[properties]
	_k_adjacent="def(coords) map(adjacents, 'adj', on_piece([adj[0]*consts.tile_size*2 + coords[0], adj[1]*consts.tile_size*2 + coords[1]]))"
	_k_touching="def(coords, side, black)
			if(not size(filter(adjs, 'adj', adj = null())) = size(adjs), 
				map(filter(adjs, 'adj', adj != null()), 'adj', _k_touching([adj.midpoint_x, adj.midpoint_y], side, black + adjs))[0], 
				[_k_valid(on_piece(coords), side, black)] + black
				) where adjs = map(_k_adjacent(coords), 'obj', _k_valid(obj, side, black))"
	_k_valid="def(obj, side, black) if(obj.animation=side and (not obj in black), obj, null())"
	add_tile="def(tile, coords) [
			set(tile.vars.gridloc, coords),
			set(tile.midpoint_x, tile_at(coords)[0]), 
			set(tile.midpoint_y, tile_at(coords)[1]), 
			set(vars.play, vars.play + [tile]),
			fire_event('tiles_in_play_modified')]"
	adjacent_objs="def(coords) filter(map(adjacents, 'adjv', find(vars.play, 'tile', tile.vars.gridloc = [coords[0]+adjv[0], coords[1]+adjv[1]])), 'list', list != null)"
	adjacents="[[-1,0],[0,-1],[1,0],[0,1]]"
	ai_die_war="def(coord) (1d2)-1"
	board_size="def() consts.tile_size*consts.tiles"
	clear_blackout="map(level.chars, 'obj', if(obj.type = 'civ_board.no', fire_event(obj, 'nix')))"
	dealt_hand_loc="def(player, spot) if(spot in range(vars.hand_size) and player = 0,
		[x - consts.tile_size + margin + step * spot, y + board_size()*2 + space_beneath]
		where step = ((board_size() - margin) * 2) / (vars.hand_size - 1)
		where margin = 125
		where space_beneath = 20
		)"
	draw_blackout="def(tile) map(range(consts.tiles), 'cX', map(range(consts.tiles), 'cY', 
			if(not is_valid_addition(tile,[cX, cY]) and 'human' = consts.players[vars.turn], 
				spawn('civ_board.no', tile_at([cX,cY])[0], tile_at([cX, cY])[1], facing))))"
	flatten="def(items) if(items.size = 0, [], items[0] + flatten(items[1:size(items)]))"
	get_terrain="def(coords) switch(consts.land[coords[0] + coords[1]*consts.tiles], 0, 'ocean_grid', 1, 'plains_grid', 2, 'hill_grid', 3, 'ore_grid', 'ocean_grid')"
	has_food="def(obj, coords) 
			has_food_with(obj, coords, [-1,-1])"
	has_food_with="def(obj, coords, less) 
			if(1 in map(adjacents, 'offset', 
				if(get_terrain([coords[0]+offset[0],coords[1]+offset[1]]) = 'plains_grid'
				and find(vars.play, 't', t.midpoint_x = tile_at([coords[0]+offset[0], coords[1]+offset[1]])[0] 
				and t.midpoint_y = tile_at([coords[0]+offset[0], coords[1]+offset[1]])[1]) = null(),
					if([coords[0]+offset[0],coords[1]+offset[1]] = less, 0, 1), 
					0)
				), 
				1,
				0)
			or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)
		#	or 'civ-tile_farm' in map(k_group(tile_at(coords), obj.animation), 'k_tile', k_tile.type)
		#"
	help="def(string) vars.help_obj.set_text(string)"
	is_valid_addition="def(obj, coords) 
			switch(obj.type,
			'civ-tile_farm',	if(get_terrain(coords) = 'plains_grid' and (not played(coords)), 1, 0),
			'civ-tile_mine',	if(get_terrain(coords) in ['hill_grid', 'ore_grid'] and has_food(obj, coords) and (not played(coords)) and ((not find(starve(obj, coords), 'dead', dead.animation = obj.animation)) or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)), 1, 0),
			'civ-tile_settle',	if(get_terrain(coords) != 'ocean_grid' and has_food(obj, coords) and (not played(coords)) and ((not find(starve(obj, coords), 'dead', dead.animation = obj.animation)) or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)), 1, 0),
			'civ-tile_war',		if(get_terrain(coords) != 'ocean_grid' and has_food(obj, coords) and (not find(vars.play, 'tile', tile.gridloc = coords and tile.animation = obj.animation)) and ((not find(starve(obj, coords), 'dead', dead.animation = obj.animation)) or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)), 1, 0),
			0)"
	k_group="def(coords, side) filter(_k_touching(coords, side, []), 'obj', obj != null())"
	mouse="level.player.vars.mouse.pos"
	mouse_on_tile="def() on_any_tile(level.player.vars.mouse.pos)"
	on_any_tile="def(coords) 
			if(mx > x and mx < x+board_size()*2 and my > y and my < y+board_size()*2,
				[tx, ty])
			where tx = (mx-x)/(consts.tile_size*2)
			where ty = (my-y)/(consts.tile_size*2)
			where mx = coords[0] where my = coords[1]"
	on_piece="def(coords) find(vars.play, 'vp', vp.vars.gridloc = on_any_tile(coords))"
	on_tile="def(coords) 
			if(not loc in map(vars.play, 'vp', vp.vars.gridloc), loc) where loc = on_any_tile(coords)"
	played="def(coords) find(vars.play, 'tile', tile.gridloc = coords)"
	starve="def(obj, coords) filter(adjacent_objs(coords), 'adjs', not has_food_with(obj, adjs.vars.gridloc, coords))"
	tile_at="def (coord) [x+consts.tile_size+x_in*consts.tile_size*2,y+consts.tile_size+y_in*consts.tile_size*2] where x_in = coord[0] where y_in = coord[1]"
	tile_name="def(tile) switch(tile.type, 'civ-tile_mine', ~mine~, 'civ-tile_farm', ~farm~, 'civ-tile_settle', ~settlement~, 'civ-tile_war', ~warrior camp~, ~claim~)"
	tile_side_name="def(name) switch(name.animation, 'normal', ~White~, 'gold', ~Gold~, 'black', ~Black~, 'silver', ~Silver~, ~Mysterious Stranger~)"
	war_defeat_tile="def(tile) [
			set(vars.play, filter(vars.play, 'vp', vp != tile)),
			fire_event(tile, 'nix'),
			fire_event('tiles_in_play_modified'),
			[add_object(war_obj), 
			set(war_obj.midpoint_x, tile.midpoint_x), 
			set(war_obj.midpoint_y, tile.midpoint_y)
			] where war_obj = object('civ_war', x, y, facing), 
			]"
	[/properties]

	[animation]
	duration="6541"
	frames="1"
	h="16"
	id="normal"
	image="experimental/civ-tile.png"
	pad="-1"
	surface_area="all"
	w="16"
	x="0"
	y="0"
	[/animation]

	[object_type]
	hitpoints="2"
	id="tile"
	on_create="[
			#set(red, tint), set(green, tint), set(blue, tint),#
			set(alpha, tint),
			] where tint = 75"
	zorder="-8"
		[animation]
		duration="5541"
		frames="1"
		h="16"
		id="normal"
		image="experimental/civ-stuff.png"
		pad="-1"
		surface_area="all"
		w="16"
		x="11"
		y="10"
		[/animation]

	[/object_type]

	[object_type]
	hitpoints="2"
	id="no"
	on_create="[
			#set(red, tint), set(green, tint), set(blue, tint),#
			set(alpha, tint),
			] where tint = 75"
	on_nix="die()"
	zorder="9"
		[animation]
		duration="6541"
		frames="1"
		h="16"
		id="normal"
		image="experimental/civ-stuff.png"
		pad="-1"
		surface_area="all"
		w="16"
		x="30"
		y="10"
		[/animation]

	[/object_type]

	[object_type]
	hitpoints="2"
	id="ocean_grid"
	zorder="-10"
		[animation]
		duration="542"
		frames="1"
		h="16"
		id="normal"
		image="experimental/civ-stuff.png"
		pad="-1"
		surface_area="all"
		w="16"
		x="14"
		y="85"
		[/animation]

	[/object_type]

	[object_type]
	hitpoints="2"
	id="plain_grid"
	zorder="-10"
		[animation]
		duration="543"
		frames="1"
		h="16"
		id="normal"
		image="experimental/civ-stuff.png"
		pad="-1"
		surface_area="all"
		w="16"
		x="14"
		y="108"
		[/animation]

	[/object_type]

	[object_type]
	hitpoints="2"
	id="hill_grid"
	zorder="-10"
		[animation]
		duration="544"
		frames="1"
		h="16"
		id="normal"
		image="experimental/civ-stuff.png"
		pad="-1"
		surface_area="all"
		w="16"
		x="14"
		y="153"
		[/animation]

	[/object_type]

	[object_type]
	hitpoints="2"
	id="ore_grid"
	zorder="-10"
		[animation]
		duration="999999999"
		frames="1"
		h="16"
		id="normal"
		image="experimental/civ-stuff.png"
		pad="-1"
		surface_area="all"
		w="16"
		x="33"
		y="153"
		[/animation]

		[animation]
		duration="999999999"
		frames="1"
		h="16"
		id="normal"
		image="experimental/civ-stuff.png"
		pad="-1"
		surface_area="all"
		w="16"
		x="52"
		y="153"
		[/animation]

		[animation]
		duration="999999999"
		frames="1"
		h="16"
		id="normal"
		image="experimental/civ-stuff.png"
		pad="-1"
		surface_area="all"
		w="16"
		x="71"
		y="153"
		[/animation]

	[/object_type]

[/object_type]

