[prototype]
	solid_dimensions=player,common,boss
	vehicle=false
	is_human=true

	[properties]
		scripted_move_to_x="def(target_x, target_facing, callback)
		                    [
		                    set(me.tmp.scripted_target_x, target_x),
							set(me.tmp.scripted_target_facing, target_facing),
							set(me.tmp.scripted_move_callback, callback),
							fire_event(me, 'handle_move_script')
							]
		                    "
	[/properties]

	on_change_animation_failure="[animation(previous_animation)]"
	
	#if the player gets 'stuck' in a narrow gap, this gets them out by
	#automatically making them jump
	on_stuck="if(not underwater, [animation('jump'), add(velocity_y, -vars.jump_power)])"

	on_enter_anim="set(tmp.already_hit, [])"

	on_hurtflicker="if(green = 100,[set(green, 255), set(blue, 255)], [set(green, 100), set(blue, 100)])"
	on_leave_hurt_anim="[set(green, 255), set(blue, 255)]"
	on_end_hurt_anim="animation('stand')"

	on_handle_move_script="
	   if(abs(midpoint_x - tmp.scripted_target_x) < 10,
		  if(abs(tmp.scripted_target_facing) = 1 and facing != tmp.scripted_target_facing,
		  [set(control_lock, if(tmp.scripted_target_facing > 0, ['ctrl_right'], ['ctrl_left'])), schedule(1, fire_event('handle_move_script'))],

		  [set(control_lock, null()),
		   set(me.tmp.scripted_target_x, null()),
		   set(me.tmp.scripted_target_facing, null()),
		   set(me.tmp.scripted_move_callback, null()),
		   tmp.scripted_move_callback]),
	   
		[set(control_lock, if(tmp.scripted_target_x > midpoint_x, ['ctrl_right'], ['ctrl_left'])), schedule(1, fire_event('handle_move_script'))])"

	on_ctrl_jump="if(is_standing and (not (animation in ['interact'])), [
    animation('jump'),
    set(velocity_x, velocity_x + velocity_x/2),
    if(ctrl_down and is_standing_on_platform,
        [set(fall_through_platforms, 10),
        set(velocity_y, velocity_y + jump_power/10)],
        [set(velocity_y, velocity_y - jump_power),
        add(velocity_x, velocity_x/2)])])"
	on_ctrl_up="[
	if(abs(velocity_x) < 100 and is_standing, map(filter(level.active_chars, 'char', collides(context.me, 'body', char, 'interact')), 'obj', [set(tmp.interacting_with, obj), fire_event(obj, 'interact')]))]"

	on_start_interact="[animation('interact'), set(tmp.fired_talk, 0)]"
	on_interacting="if(tmp.interacting_with and tmp.fired_talk = 0, [set(tmp.fired_talk, 1), fire_event(tmp.interacting_with, 'talk')])"

	on_end_interact_anim="animation('stand')"

	##Damage handlers:
			# If we get hit, it's important that we're only hit once by an attack.  Each attacker keeps a list of what they've already hit to make sure that doesn't happen.  This checks/populates that list as appropriate.  The attacker is responsible for clearing the list as appropriate.
			# we also have a primitive window of 3 seconds of post-hit invincibility here for all sources of damage
	on_collide_object_body=" if( collide_with_area = 'attack' and (not is_invincible(self)) and collide_with.vars.team != vars.team and collide_with.vars.damage > 0,
		if(not (me in collide_with.tmp.already_hit), [set(collide_with.tmp.already_hit, collide_with.tmp.already_hit + [me]),
	
			set(hitpoints, hitpoints - collide_with.vars.damage), animation('hurt'), set(green, 100), set(blue, 100), set(velocity_y,-1000), set(velocity_x,400 * collide_with.facing), set(tmp.time_last_hit, cycle)]),

			#see if we're colliding with another object's interact area, in which case
			 we set it so we can interact with them.#
			if(collide_with_area = 'interact', set(can_interact, 2))
)"

    functions="
	  #Function to test if frogatto is invincible.#
	  def is_invincible(object_type obj)
	  	if(obj.invincible or obj.level.in_dialog or obj.tmp.time_last_hit and (abs(obj.tmp.time_last_hit - obj.cycle) < 100), 1, 0);

	  #Function to do a water-equivalent of standing.#
	  def float(object_type obj)
		animation('swim_side_idle')"
	    
[/prototype]
