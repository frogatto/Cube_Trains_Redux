[object_type]
	id=tracked_dungeon_platform
	zorder=-1
	surface_friction=100
	platform_area=0,0,48,1
	
	[editor_info]
		category=platforms
		help="A platform which moves on tracks between points.
				Usually, these points are track_platform_point_targets.
				Group points + platform in editor for proper activation.
				
				move_speed: How fast to move. Default is 10.
				linked_object: Which object to move to.
				always_moving: Start in motion, or wait for player?
				on_end: What to do at the end of the track.
				     -1: Fall off.
				     0: Stay still.
				     1: Reverse. (crashes atm, don't use)"
		[var]
			name=move_speed
			type=int
			value=10
		[/var]
		[var]
			name=linked_object
			type=label
			value="''"
		[/var]
		[var]
			name=always_moving
			type=boolean
			value="0"
		[/var]
		[var]
			name=on_end
			type=int
			value="0"
		[/var]
	[/editor_info]
	
	[properties]
		#public#
		stop = "set(tmp.stop, 1)"		#stop the platform
		go = "fire_event('move')"		#start the platform
		switch_track = "def(from_point, to_point) [
			#Make the point from_point to link to the point to_point.
			Note: The reverse code doesn't like junctions, so be careful to set the switches correctly for reversing if you plan to reverse.#
			set(from_point.vars.linked_object, to_point.label), 
			_get_points(vars.points, to_point.label)]"
		
		#internal#
		set_pos = "def(coords) [set(vars.decimal_position, coords), set(self.midpoint_x, coords[0]), set(self.midpoint_y, coords[1])]"
		get_pos = "if(vars.decimal_position, vars.decimal_position, get_target_pos(self))" #first cycle, decimal_position isn't set
		get_target_pos = "def(target) [target.midpoint_x, target.midpoint_y]"
		point_length = "def(p1, p2) length(p1[0], p1[1], p2[0], p2[1])"
		advance = "_advance(get_pos, vars.move_speed, vars.target)"
		_advance = "def(start, distance, target) 
			if(point_length(start, get_target_pos(target)) > distance,
				set_pos(list_add(
					start, 
					list_single_multiply(
						list_single_divide(
							list_subtract(
								start,
								get_target_pos(target)), 
							decimal(-point_length(
								start, 
								get_target_pos(target)))), 
						distance))),
				[	set_pos(get_target_pos(target)),
					if(new_target, 
						set(vars.target, new_target), 
						switch(vars.on_end,
							1, set(vars.get_next_point, if(not vars.get_next_point = _get_next_point_reverse, _get_next_point_reverse, _get_next_point_foward)),
							0, stop,
							-1, [	stop,
									set(accel_y, 50)],
							[	debug('Bad end value for {self.type}. ({self})'), 
								stop]))
				] where new_target = get_next_point(target))"
		get_next_point = "if(vars.get_next_point, vars.get_next_point, _get_next_point_foward)"
		_get_next_point_foward = def(obj) find(vars.points, 'vp', vp.label = obj.vars.linked_object)
		_get_next_point_reverse = def(obj) find(vars.points, 'vp', vp.vars.linked_object = obj.label)
		get_points = "if(vars.linked_object, 
			_get_points([], vars.linked_object), 
			stop)"
		_get_points = "def(got, next) if(next_obj and (not next_obj in got), 
			_get_points(got+[next_obj], next_obj.vars.linked_object),
			[	set(vars.points, got),
				if(size(got), set(vars.target, got[0])),
			]) where next_obj = get_object(level, next)"
		get_next = "def(label) filter(vars.points, 'point', point.label = label)"
	[/properties]
		
	on_create = "[
		get_points,
		if(always_moving, fire_event('move'), fire_event('lurk')),
		set(vars.move_speed, decimal(vars.move_speed)/4),
		]"
		
	on_lurk = "if(level.player.standing_on=me, fire_event('move'), schedule(1, fire_event('lurk')))"
		
	on_move = "if(tmp.stop, 
			set(tmp.stop, 0),
			[	schedule(1, fire_event('move')),
				advance,
			])"
		
	[animation]
		id=normal
		image=props/dungeon-platform.png
		x=0
		y=0
		w=48
		h=16
	[/animation]
[/object_type]