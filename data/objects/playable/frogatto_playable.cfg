	[object_type]
	id=frogatto_playable
	hitpoints=4
	feet_width=1
	mass=5
	friction=2000
	solid_area=9,8,23,30
	solid_dimensions=player,common,boss
	vehicle=false
	is_human=true
	traction_in_water=1000
	affected_by_currents=yes

	#this spritesheet gets switched for fat frogatto, so we can't compile it.
	no_compile_image="characters/frogatto-spritesheet1.png"

		[editor_info]
		category=player
		[/editor_info]

		[properties]
		attack_force="if(animation = 'run_attack', 140, 20)"
		get_hit_by="def(collide_with) [
	  	            if(me.tmp.time_last_hit and (abs(me.tmp.time_last_hit - me.cycle) < 100) or collide_with.vars.damage <= 0, [],
				    [add(me.hitpoints, -if(collide_with, collide_with.vars.damage, 1)),
					 set(me.tmp.time_last_hit, me.cycle),
					 set(solid_dimensions_in, ['player']),
					 set(me.animation, 'hurt')
					 ])]"
		energy_charge="if((not FAT) and vars.has_energy_shot,
		            min(vars.charge_time, cycle - tmp.start_attack_cycle), 0)"

		scripted_move_to_x="def(target_x, target_facing, callback)
		                    [
		                    set(me.tmp.scripted_target_x, target_x),
							set(me.tmp.scripted_target_facing, target_facing),
							set(me.tmp.scripted_move_callback, callback),
							fire_event(me, 'handle_move_script')
							]
		                    "

		[/properties]

		#on_display_gold="spawn('text_flash',midpoint_x,midpoint_y,1,[set_var('txt','+1')])"

		on_display_gold="[ if( (cycle - vars.last_got_gold > 20) and (vars.gold_counter > 0), [spawn('text_flash',midpoint_x,midpoint_y,1,[set_var('txt','+'+vars.gold_counter)]), set(vars.gold_counter,0)], schedule(10,fire_event('display_gold')))]"

		on_handle_move_script="
		   if(abs(midpoint_x - tmp.scripted_target_x) < 10,
			  if(abs(tmp.scripted_target_facing) = 1 and facing != tmp.scripted_target_facing,
              [set(control_lock, if(tmp.scripted_target_facing > 0, ['ctrl_right'], ['ctrl_left'])), schedule(1, fire_event('handle_move_script'))],

		      [set(control_lock, null()),
			   set(me.tmp.scripted_target_x, null()),
			   set(me.tmp.scripted_target_facing, null()),
			   set(me.tmp.scripted_move_callback, null()),
			   tmp.scripted_move_callback]),
		   
		    [set(control_lock, if(tmp.scripted_target_x > midpoint_x, ['ctrl_right'], ['ctrl_left'])), schedule(1, fire_event('handle_move_script'))])"

		[consts]
		JUMP_OUT_OF_WATER_BOOST=1400
		JUMP_OUT_OF_WATER_BOOST_HORIZONTAL=200
		FAT=0
		max_swallow_size=16
		powerup_name=''
		powerup_recharge=0
		[/consts]

		[vars]
		levels_visited="[]"
		powerup_time=0
		damage=0
		swim_accel=140
		unlocked_items="['heart_object','points_cube','points_cube']"
		next_unlocked_item="null()"
		team="'player'"
		charge_time=50
		coins=0
		items_owned="[]"
		jump_power=1200
		jump_boost=90
		jump_glide=30
		walk_accel=1600
		run_accel=2800
		num_partial_hearts=0

		swallowed="null()"

		has_energy_shot=0

		tongue_length=10

		spit_power=80
		[/vars]

		[tmp]
		start_attack_cycle=0
		time_last_hit=0
		left=0
		right=0
		running=0
		last_shield=0
		shield="null()"
		no_flinch_attack=0

		scripted_target_x="null()"
		scripted_target_facing="null()"
		scripted_move_callback="null()"

		tongue_tip="null()"
		tongue_shaft="null()"

		#indicates whether the last press of jump was while in the air.
		pressed_jump_in_air="0"
		[/tmp]

	functions="
	  #function which returns true if the object is in an animation that
	   requires frogatto be on the ground#	
	  def animation_requires_standing(object_type obj)
	    obj.animation in ['stand', 'stand_up_slope', 'stand_down_slope', 'run', 'walk', 'land', 'lookup', 'crouch', 'enter_crouch', 'leave_crouch', 'turn', 'roll','skid'];
	  def set_facing(object_type obj, facing) if(obj.facing != facing and (not (obj.animation in ['interact', 'slide'])),
	           [facing(facing), if(obj.is_standing, animation('turn'))]);

	  def stand(object_type obj)
	   if(abs(obj.velocity_x) > 240 and (not obj.animation in ['walk']), animation('skid'),
	     if(abs(obj.slope_standing_on) < 20, animation('stand'),
		   if(obj.slope_standing_on*obj.facing > 0, animation('stand_down_slope'),
			                                animation('stand_up_slope'))));


	  #make Frogatto walk. anim can be either 'walk' or 'run'. Does checking
	   to make sure Frogatto is in a state where he can walk or run.
	   Will make Frogatto 'glide' if in mid air.#
	  def walk(object_type obj, dir, anim)
	    if(obj.is_standing and (not (obj.animation in ['walk', 'run', 'jump', 'jump_attack', 'turn', 'run', 'crouch', 'enter_crouch', 'roll', 'run_attack', 'energyshot', 'attack', 'up_attack', 'interact', 'spit'])), [animation(anim), if(anim = 'run', [sound('run.wav')])],
	       #Frogatto is in the air, so make him glide.#
		   if(((not obj.is_standing) and (not (obj.animation in ['slide', 'swim_up', 'swim_down', 'swim_side']))), add(obj.velocity_x, obj.vars.jump_glide*dir)));

	  #Function to attempt to make Frogatto crouch; does checking to make
	   sure he's in a state that allows entering a crouch.#
	  def crouch(object_type obj)
	  	if(((not obj.animation in ['crouch', 'enter_crouch', 'roll', 'interact'] ) and obj.is_standing), animation('enter_crouch'));
	  def roll(object_type obj)
	    if( (not FAT) and (obj.animation in ['crouch']) and obj.is_standing, animation('roll'));
	
	 def tongue(object_type obj)
	  if('fat' in obj.variations,
				if(not (obj.animation in ['interact']), [animation('spit')]),
				[
					if(obj.animation in ['run'], animation('run_attack')),
					if(obj.animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'enter_lookup', 'lookup','skid', 'land'],
					    animation(if(obj.ctrl_up, 'up_', '') + 'attack')),
					if(obj.animation in ['jump', 'fall'],
							if(obj.ctrl_down or obj.ctrl_jump and (not obj.ctrl_tongue), animation('fall_spin_attack'),
							animation('jump_attack')))
				]
		);
	
	  #Function to make Frogatto attack. Does checking and chooses the
	   appropriate type of attack animation, if any.#
	  def attack(object_type obj, charge_cycles)
	  [if('fat' in obj.variations, tongue(obj),
				[
					if((obj.animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'enter_lookup', 'lookup','skid', 'land']) and
					  charge_cycles >= obj.vars.charge_time, animation(if(obj.ctrl_up, 'up_', '') + 'energyshot')),
					
					if(obj.animation in ['run'], animation('run_attack')),
	
					if(obj.animation in ['swim_side','swim_side_idle'], animation(if(charge_cycles >= obj.vars.charge_time, 'energyshot_swim_side', 'swim_side')) ),

					if(obj.animation in ['swim_down','swim_down_idle'], animation(if(charge_cycles >= obj.vars.charge_time, 'energyshot_swim_down', 'swim_down')) ),

					if(obj.animation in ['swim_up','swim_up_idle'], animation(if(charge_cycles >= obj.vars.charge_time, 'energyshot_swim_up', 'swim_up')) ),
					
					if((obj.animation in ['jump', 'fall']) and
					   charge_cycles >= obj.vars.charge_time,
					   if(obj.ctrl_down, animation('energyshot_down'),
						  if(obj.ctrl_up, animation('up_energyshot'),
							animation('energyshot_jump')))),
					
					if(obj.animation in ['enter_crouch', 'crouch'] and (charge_cycles >= obj.vars.charge_time), animation('energyshot_crouch'))]
				
	    )];

	  #Function to do a water-equivalent of standing.#
	  def float(object_type obj)
		animation('swim_side_idle');
	    
	  #Function to enter swimming frames.#
	  def swim(object_type obj,dirx,diry)
	    if(dirx or diry,
		 [
		  if(obj.animation != anim_wanted, animation(anim_wanted)),
		 add(obj.velocity_x, (obj.swim_accel*dirx)/1000),
		 add(obj.velocity_y, (obj.swim_accel*diry)/1000)
		 ])
			where anim_wanted = if(abs(diry) > 500, if(diry < 0, 'swim_up', 'swim_down'), 'swim_side')	
		;
		   
	  #Function to test if frogatto is invincible.#
	  def is_invincible(object_type obj)
	  	if(obj.invincible or obj.level.in_dialog or obj.tmp.time_last_hit and (abs(obj.tmp.time_last_hit - obj.cycle) < 100), 1, 0);
	  
	  #Function to test if frogatto is blinking due to being invincible#
	  def is_blinking_invincible(object_type obj)
	  	if(obj.tmp.time_last_hit and (abs(obj.tmp.time_last_hit - obj.cycle) < 100), 1, 0);

	  #function to decide if frogatto can slide down a wall#
		def can_slide(object_type obj)
		   (not FAT) and
           solid(obj.level, if(obj.facing > 0, obj.solid_rect.x2+1, obj.solid_rect.x-1), (obj.solid_rect.y + obj.solid_rect.y2*2)/3) and
		   (obj.velocity_y < 300 and obj.velocity_y > -1000 or obj.ctrl_jump and obj.tmp.pressed_jump_in_air);


	   def swallowing_object(object_type frog)
	     if(frog.attached_objects, map(frog.attached_objects, 'obj',
	      if(abs(obj.midpoint_x - context.frog.midpoint_x) < 4, set(attached_objects, []), add(obj.midpoint_x, if(obj.midpoint_x > context.frog.midpoint_x, -4, 4)))
		  ));
	   
	   def bounce_on(object_type frog, obj)
	     [set(frog.velocity_y, -max(obj.consts.spring_amount,
		              (((frog.velocity_y*obj.consts.springiness)/100)*
					    (100 - abs(bounce_angle)))/100)),
		 add(frog.velocity_x, (((frog.velocity_y*obj.consts.springiness)/100)*bounce_angle)/100),
		 fire_event(obj, 'bounced_on'),
		 if(frog.animation = 'fall_spin_attack', fire_event(obj, 'stomped_on'))
		 ]
		   where bounce_angle = (obj.consts.bounce_roundness*(frog.midpoint_x - obj.midpoint_x))/(max(1, obj.w));


	  1"

	#give frogatto brief invincibility when we load
	on_load="[if((not lights), set(lights, circle_light(me, 160))),
	          set(invincible, 50), set(brightness, 255)]"

	on_create="[set(lights, circle_light(me, 160)), animation('stand')]"
	on_enter_level="[if(not (level.id in vars.levels_visited),
	                 add(vars.levels_visited, [level.id])),
					 animation('stand')]"

	on_load_checkpoint="[if((not lights), set(lights, circle_light(me, 160))),
	                     set(hitpoints, max_hitpoints),

	                     #make it so that if we had a swallowed object
						  we create a fresh version of the object in our
						  stomach.#
	                     if(vars.swallowed,
							[
						    set(vars.swallowed, obj),
							set(obj.vars.removed_from_play, 1),
							fire_event(obj, 'swallowed')
							] where obj = object(vars.swallowed.type,
							                midpoint_x, midpoint_y, facing)
							),
						 set(vars.powerup_time, 0),
						 set(vars.has_energy_shot, 0),
						 fire_event('lose_powerup'),

	                     #remove variations that aren't upgrades#
						 set(variations, filter(variations, 'v', strstr(v, 'upgrade') or v = 'fat')),
						 animation('stand'),
						 set(velocity_x, 0),
						 set(velocity_y, 0),
						 move_to_standing(),
						 set(brightness, 255),
						 schedule(2, fire_event('check_water'))
						 ]"

	#when jumping we have a zorder that puts us in front of certain tiles, so
	#take care of setting the zorder when entering and leaving such animations.
	on_enter_fall_anim="set(zorder, 10)"
	on_enter_fall_spin_attack_anim="[set(zorder, 10), add(velocity_y, 500), set(velocity_x, velocity_x/2), set(tmp.no_flinch_attack, 1)]"
	on_enter_jump_anim="set(zorder, 10)"
	on_enter_jump_attack_anim="set(zorder, 10)"
	on_enter_slide_anim="[set(zorder, 10),
	  if(IPHONE_SYSTEM, set(underwater_controls, 0))]"

	on_leave_fall_anim="set(zorder, 0)"
	on_leave_fall_spin_attack_anim="[set(zorder, 0), set(tmp.no_flinch_attack, 0)]"
	on_leave_jump_anim="set(zorder, 0)"
	on_leave_jump_attack_anim="[fire_event('leave_attack_anim'), set(zorder, 0), set(attached_objects, [])]"
	on_leave_slide_anim="[set(zorder, 0), if(ctrl_left, facing(-1)), if(ctrl_right, facing(1))]"

	on_enter_walk_anim="set(accel_x, vars.walk_accel)"
	on_enter_run_anim="set(accel_x, vars.run_accel)"

	#if the player gets 'stuck' in a narrow gap, this gets them out by
	#automatically making them jump
	on_stuck="if(not underwater, [animation('jump'), add(velocity_y, -vars.jump_power)])"

	#on_collide_with="set(hitpoints, hitpoints - 1)"
	on_die="[spawn('die_cloud', midpoint_x, midpoint_y, facing)]"
	on_ctrl_left="[set_facing(self, -1), roll(self), if(tmp.left and tmp.left > cycle - 15 or tmp.running = 1, [walk(self, -1, 'run'), set(tmp.running, 1)]), set(tmp.left, cycle), set(tmp.right, null())]"
	on_ctrl_right="[set_facing(self, 1), roll(self), if(tmp.right and tmp.right > cycle - 15 or tmp.running = 1, [walk(self, 1, 'run'), set(tmp.running, 1)]), set(tmp.right, cycle), set(tmp.left, null())]"
	on_ctrl_jump="[set(tmp.pressed_jump_in_air, (not is_standing)),
				   if(is_standing and velocity_y >= 0 and (not (animation in ['interact'])), [animation('jump'), add(velocity_x, velocity_x/2), if(ctrl_down and is_standing_on_platform, [set(fall_through_platforms, 15), add(velocity_y, vars.jump_power/10)], set(velocity_y, -vars.jump_power))]),
	            if(animation = 'slide', [facing(-facing), animation('jump'), set(velocity_x, -facing*800), set(velocity_y, -1000)])]"
	

	#pressing up or down while jumping triggers an attack
	on_ctrl_down="if((not FAT), if(animation in ['fall', 'jump'], [tongue(self)]))"
	on_ctrl_tongue="if(vars.has_energy_shot, attack(self, energy_charge), tongue(self))"
	on_ctrl_up="[
	if(abs(velocity_x) < 100 and is_standing, map(filter(level.active_chars, 'char', collides(context.me, 'body', char, 'interact')), 'obj', [set(tmp.interacting_with, obj), fire_event(obj, 'interact')]))]"

	on_start_interact="[animation('interact'), set(tmp.fired_talk, 0)]"
	on_interacting="if(tmp.interacting_with and tmp.fired_talk = 0, [set(tmp.fired_talk, 1), fire_event(tmp.interacting_with, 'talk')])"

	on_end_ctrl_up="if((animation in ['enter_lookup', 'lookup']), stand(self))"

	on_end_interact_anim="animation('stand')"

	timer_frequency=2
	on_timer="[
	    if(ctrl_right - ctrl_left != 0 and ctrl_right - ctrl_left != facing, set_facing(me, -facing)),
	    if(ctrl_up and (animation in ['stand','stand_up_slope','stand_down_slope']), animation('enter_lookup')),

#handle ending of invincibility#
	    if((cycle - tmp.time_last_hit)/2 = 50, set(solid_dimensions_in, ['player', 'common', 'boss'])),
		if(is_blinking_invincible(self), set(alpha,(wave(cycle*300)+1000)/10 + 100),
		         [if(underwater and water_object.consts.damage,
				    [add(hitpoints, -water_object.consts.damage),
					 set(tmp.time_last_hit, cycle)]),
				 set(alpha,255)])
	   ]"

	on_process="[
	    if((not is_standing) and animation_requires_standing(self), [animation('fall')]),
		if((not FAT) and underwater,
		  if(IPHONE_SYSTEM,
		    [
			  swim(self, ctrl_x, ctrl_y),
			  if((not ctrl_x) and (not ctrl_y), float(self)),
			  if(ctrl_x < 0 and facing > 0 or ctrl_x > 0 and facing < 0, set(facing, -facing))
			],

			[
			swim(self, (ctrl_right - ctrl_left)*if(ctrl_down or ctrl_up, 700, 1000), (ctrl_down - ctrl_up)*if(ctrl_left or ctrl_right, 700, 1000)),
			if((not (ctrl_left or ctrl_right or ctrl_up or ctrl_down)) and (animation in ['swim_side','swim_up','swim_down']),
		   float(self)) ]
		     ),
		   
		   ),

		   if(ctrl_left, if(tmp.running, walk(self, -1, 'run'), walk(self, -1, 'walk'))),
			if(ctrl_right, if(tmp.running, walk(self, 1, 'run'), walk(self, 1, 'walk'))),
			if(ctrl_down and (not (ctrl_left or ctrl_right)), crouch(self))
				]"

	on_process_jump="if(ctrl_jump, [add(velocity_y, -vars.jump_boost)])"
	on_process_fall="[
	    if(IPHONE_SYSTEM, if(underwater_controls, [
		         add(velocity_x, (jump_glide*ctrl_x)/1000),
		         add(velocity_y, (jump_glide*ctrl_y)/1000)])),
	    if(is_standing, animation('stand'))]"

	#check if we end up on a slope in which case we re-calculate our standing.
	on_enter_stand_anim="if(abs(slope_standing_on) > 20, stand(self))"
	on_enter_stand_up_slope_anim="if(slope_standing_on*facing > -20, stand(self))"
	on_enter_stand_down_slope_anim="if(slope_standing_on*facing < 20, stand(self))"

	on_process_lookup="[add(tmp.lookup_time, 1), if(tmp.lookup_time = 50, set(vertical_look, -200))]"
	on_process_crouch="[add(tmp.lookdown_time, 1), if(tmp.lookdown_time = 50, set(vertical_look, 200))]"
	on_leave_lookup_anim="[set(tmp.lookup_time, 0), set(vertical_look, 0)]"
	on_leave_crouch_anim="[set(tmp.lookdown_time, 0), set(vertical_look, 0)]"

	on_process_slide="if(not can_slide(self), animation('fall'))"

	on_check_water="[if(underwater, animation('swim_side')), if(IPHONE_SYSTEM, set(underwater_controls, underwater))]"

	on_enter_water="[
	    if(IPHONE_SYSTEM, set(underwater_controls, 1)),
	    if((not FAT), [float(self), set(has_feet, 0)]),
		
		sound('WaterPlunge.ogg'),

		#splash if we are entering the water with reasonable velocity#
		if(velocity_y > 200, [
			spawn('water_splash', midpoint_x, water_bounds[1]+10, if(1d2=2,facing,-facing)),
			spawn('water_particles', midpoint_x, water_bounds[1]+10, facing)]),
		#record the surface level of the water for future reference,
		 especially for splashing when we exit the water#
		set(tmp.water_surface, water_bounds[1]),
	    
	    if(HIGH_END_SYSTEM,
	    [add_wave(midpoint_x, y2, -2000, 5*velocity_y, 30*velocity_y, 300, 300),
		add_wave(midpoint_x, y2, 2000, 5*velocity_y, 30*velocity_y, 300, 300),
		add_wave(midpoint_x, y2, -1000, 3*velocity_y, 20*velocity_y, 200, 200),
		add_wave(midpoint_x, y2, 1000, 3*velocity_y, 20*velocity_y, 200, 200),
		add_wave(midpoint_x, y2, -500, 2*velocity_y, 10*velocity_y, 100, 100),
		add_wave(midpoint_x, y2, 500, 2*velocity_y, 10*velocity_y, 100, 100)])
	]
	
	"
	on_exit_water="[
	    set(has_feet, 1),
		sound('WaterPlunge.ogg'),
		schedule(60, fire_event('check_water')),

		if(velocity_y < -200,
	      [spawn('water_splash', midpoint_x, tmp.water_surface+10, if(1d2=2,facing,-facing)),
	      spawn('water_particles', midpoint_x, tmp.water_surface+10, facing),
	      
	      if(HIGH_END_SYSTEM,
	    [add_wave(midpoint_x, y2+100, 2000, -5*velocity_y, -30*velocity_y, 300, 300),
		add_wave(midpoint_x, y2+100, -2000, -5*velocity_y, -30*velocity_y, 300, 300),
		add_wave(midpoint_x, y2+100, 1000, -3*velocity_y, -20*velocity_y, 200, 200),
		add_wave(midpoint_x, y2+100, -1000, -3*velocity_y, -20*velocity_y, 200, 200),
		add_wave(midpoint_x, y2+100, 500, -2*velocity_y, -10*velocity_y, 100, 100),
		add_wave(midpoint_x, y2+100, -500, -2*velocity_y, -10*velocity_y, 100, 100)])]),

	
	animation('fall'), if(velocity_y < 0, add(velocity_y, -JUMP_OUT_OF_WATER_BOOST)),
	set(velocity_x, (velocity_x*JUMP_OUT_OF_WATER_BOOST_HORIZONTAL)/100)
	
	]"
	
	on_end_ctrl_left="[set(tmp.running, 0),
	     if((not (ctrl_left or ctrl_right)) and (animation in ['walk', 'run']), stand(self))]"
	on_end_ctrl_right="[set(tmp.running, 0),
	     if((not (ctrl_left or ctrl_right)) and (animation in ['walk', 'run']), stand(self))]"

	on_end_enter_crouch_anim="animation('crouch')"
	on_end_crouch_anim="if(ctrl_down, animation('crouch'), animation('leave_crouch'))"
	on_change_animation_failure="[animation(previous_animation)]"
	on_end_leave_crouch_anim="stand(self)"
	
	on_enter_skid_anim="if(abs(velocity_x) > 300, spawn('dust_cloud_skid', midpoint_x + 36*facing, y2 - 10, facing))"
	on_enter_land_anim="[spawn('dust_cloud_skid', midpoint_x + 20*facing, y2 - 8, facing), spawn('dust_cloud_skid', midpoint_x - 20*facing, y2 - 8, -facing)]"
	
	on_end_roll_anim="animation('crouch')"
	on_leave_roll_anim="stop_sound('roll.ogg')"
	on_end_turn_anim="stand(self)"
	on_end_jump_anim="animation('fall')"
	on_end_bumphead_anim="animation('fall')"
	on_end_land_anim="stand(self)"
	on_end_walk_anim="animation('walk')"
	on_end_run_anim="[animation('run'),  spawn('dust_cloud_run', midpoint_x + 30*facing, y2 - 12, -facing)]"
	on_end_stand_anim="stand(self)"
	on_end_skid_anim="stand(self)"
	on_end_stand_up_slope_anim="stand(self)"
	on_end_stand_down_slope_anim="stand(self)"

	on_enter_spit_anim="[set(tmp.spit_force, 0), set(variations, filter(variations, 'v', v != 'fat'))]"
	on_process_spit="if(ctrl_attack or ctrl_tongue, add(tmp.spit_force, 1))"
	on_end_spit_anim="if(underwater, float(self), stand(self))"
	on_leave_spit_anim="if(vars.swallowed, [
	     set(green, 255), set(blue, 255),
	     set(vars.swallowed.vars.removed_from_play, 0),
	     set(vars.swallowed.velocity_x, velocity_x + facing*(200 + tmp.spit_force*if(ctrl_up, vars.spit_power/2, vars.spit_power*2))),
	     set(vars.swallowed.velocity_y, velocity_y - (600 + if(ctrl_up, 200 + tmp.spit_force*vars.spit_power))),

	     #set the object's timestamp for when it was spat out, so we
		  can make ourselves invincible to it for a little while#
		 set(vars.swallowed.spat_out_at, level.cycle),
		 set(vars.swallowed, null()),

         #set the enemy to be dimensionless, meaning it will only collide
		  with the level. If it collides with another object we expect
		  it to die.#
	     set(vars.swallowed.solid_dimensions_in, ['thrown']),
		 set(vars.swallowed.midpoint_x, midpoint_x),
		 set(vars.swallowed.y, y),
	     if(vars.swallowed.vars.team, set(vars.swallowed.vars.team, vars.team)),
		 set(vars.swallowed.animation, 'thrown'),

		 resolve_solid(vars.swallowed, facing, 0, 50),
		 resolve_solid(vars.swallowed, -facing, 0, 50),

	     add_object(vars.swallowed),
		 fire_event(vars.swallowed, 'spat'),
		 if(underwater, set(has_feet, 0)),
		 sound('Spit.wav')
		 ])"
	
	on_child_spawned="if(child.type = 'frogatto_playable.tongue_tip',
	                  [set(tmp.tongue_tip, child), set(child.tmp.tongue_shaft, tmp.tongue_shaft)],
					  if(child.type = 'frogatto_playable.tongue_shaft',
					  set(tmp.tongue_shaft, child)))"
	
	on_remove_tongue="[if(tmp.tongue_tip.vars.swallowed,
	                        [set(vars.swallowed, tmp.tongue_tip.vars.swallowed),
							 add(variations, ['fat'])]),
	                       set(tmp.tongue_tip.hitpoints, 0),
	                       set(tmp.tongue_tip, null()),
	                       set(tmp.tongue_shaft.hitpoints, 0),
	                       set(tmp.tongue_shaft, null())]"

	on_process_attack="
			   if(tmp.tongue_tip and tmp.tongue_tip.tmp.hit and time_in_animation < 9,
				   [add(time_in_animation, 2*(9-time_in_animation) + 1),
								fire_event('process_attack')],
	
	              [if(time_in_animation = 4,
	                    [
						 spawn('frogatto_playable.tongue_shaft',
						       if(facing > 0, x + 30, x), y + 44, facing),
						 spawn('frogatto_playable.tongue_tip', 
						      if(facing > 0, x + 30, x), y + 46, facing)
						 ]),
						if(tmp.tongue_tip and time_in_animation = 14,
						   fire_event('remove_tongue')),
						if(tmp.tongue_tip,
						   [
					         set(tmp.tongue_tip.midpoint_x,
							    midpoint_x + facing*(10 + tongue_length)),
						   
						    set(tmp.tongue_tip.midpoint_y, y + 47),
							set(tmp.tongue_shaft.x,
							    if(facing > 0, midpoint_x + 10,
								   midpoint_x - 2 - tongue_length)),
							tmp.tongue_shaft.set_length(tongue_length - 6),
							set(tmp.tongue_shaft.midpoint_y, y + 44)
							]),
							if(tmp.tongue_tip, fire_event(tmp.tongue_tip, 'calculate_position')),
	                     swallowing_object(self)])
					   where tongue_length = vars.tongue_length*(5 - abs(9 - time_in_animation))
					   "


	on_process_jump_attack="
			   if(tmp.tongue_tip and tmp.tongue_tip.tmp.hit and time_in_animation < 9,
				   [add(time_in_animation, 2*(9-time_in_animation) + 1),
								fire_event('process_jump_attack')],
	
	              [if(time_in_animation = 4,
	                    [
						 spawn('frogatto_playable.tongue_shaft',
						       if(facing > 0, x + 30, x), y + 32, facing),
						 spawn('frogatto_playable.tongue_tip', 
						      if(facing > 0, x + 30, x), y + 34, facing)
									   ]),
						if(tmp.tongue_tip and time_in_animation = 14,
						   fire_event('remove_tongue')),
						if(tmp.tongue_tip,
						    [
							 set(tmp.tongue_tip.midpoint_x, midpoint_x + facing*(10 + tongue_length)),
						    set(tmp.tongue_tip.midpoint_y, y + 35),
							set(tmp.tongue_shaft.x,
							    if(facing > 0, midpoint_x + 10,
								   midpoint_x - 10 - tongue_length)),
							tmp.tongue_shaft.set_length(tongue_length - 6),
							set(tmp.tongue_shaft.midpoint_y, y + 32)
							
							]),
							if(tmp.tongue_tip, fire_event(tmp.tongue_tip, 'calculate_position')),
	                     swallowing_object(self)])
					   where tongue_length = vars.tongue_length*(5 - abs(9 - time_in_animation))
					   "
	
	on_enter_energyshot_anim="[set(tmp.start_attack_cycle, cycle),
	        spawn('frogatto_energy_ball', midpoint_x + facing*30, midpoint_y +10, facing, [set(velocity_x, velocity_x/2 + facing*700), set(velocity_y, velocity_y/2)])]"

	#note that when we jump and shoot we only add our velocity to the
	#shot if that makes it faster, not slower.
	on_enter_energyshot_jump_anim="[set(tmp.start_attack_cycle, cycle),
	             spawn('frogatto_energy_ball', midpoint_x + facing*30, midpoint_y +10, facing, [set(velocity_x, if(velocity_x*facing > 0, velocity_x/2, 0) + facing*700)])]"
	on_enter_up_energyshot_anim="[set(tmp.start_attack_cycle, cycle),
	       spawn('frogatto_energy_ball', midpoint_x, midpoint_y -40, facing, [set(velocity_x, velocity_x/2), set(velocity_y, min(velocity_y/2, 0) - 700)])]"
	on_enter_energyshot_down_anim="[set(tmp.start_attack_cycle, cycle),
	       spawn('frogatto_energy_ball', midpoint_x, midpoint_y + 40, facing, [set(velocity_x, velocity_x/4), set(velocity_y, velocity_y + 1500)])]"
	on_enter_energyshot_crouch_anim="[set(tmp.start_attack_cycle, cycle),
	        spawn('frogatto_energy_ball', midpoint_x + facing*30, midpoint_y, facing, [set(velocity_x, velocity_x/2 + facing*700), set(velocity_y, velocity_y/2)])]"

	on_enter_energyshot_swim_side_anim="[set(tmp.start_attack_cycle, cycle),
	     spawn('frogatto_energy_ball', midpoint_x + facing*30, midpoint_y +10, facing, [set(velocity_x, velocity_x/2 + facing*700), set(velocity_y, velocity_y/2)])]"
	on_enter_energyshot_swim_up_anim="[set(tmp.start_attack_cycle, cycle),
	         spawn('frogatto_energy_ball', midpoint_x, midpoint_y -40, facing, [set(velocity_x, velocity_x/2), set(velocity_y, velocity_y/2 - 700)])]"
	on_enter_energyshot_swim_down_anim="[set(tmp.start_attack_cycle, cycle),
	      spawn('frogatto_energy_ball', midpoint_x, midpoint_y + 40, facing, [set(velocity_x, velocity_x/4), set(velocity_y, velocity_y/2 + 1500)])]"

	
	on_end_energyshot_anim="stand(self)"
	on_end_energyshot_jump_anim="stand(self)"
	on_end_up_energyshot_anim="stand(self)"
	on_end_energyshot_down_anim="stand(self)"
	on_end_energyshot_crouch_anim="stand(self)"
	on_end_energyshot_swim_side_anim="float(self)"
	on_end_energyshot_swim_up_anim="float(self)"
	on_end_energyshot_swim_down_anim="float(self)"

	on_end_attack_anim="[
		 if(('fat' in variations), animation('swallow')),
	                               stand(self)]"
	on_leave_attack_anim="[if(tmp.tongue_tip, fire_event('remove_tongue')), set(attached_objects, [])]"
	on_leave_up_attack_anim="set(attached_objects, [])"
	on_end_swallow_anim="stand(self)"
	on_end_enter_lookup_anim="animation('lookup')"
	on_end_lookup_anim="animation('lookup')"
	on_end_run_attack_anim="[animation('skid'), set(tmp.running, 0)]"
	on_end_up_attack_anim="stand(self)"
	on_end_jump_attack_anim="animation('fall')"
	on_end_fall_spin_attack_anim="animation('fall')"
	on_end_swim_side_idle_anim="float(self)"
	on_end_swim_side_anim="if(underwater,animation('swim_side'),stand(self))"
	on_end_swim_up_anim="if(underwater,animation('swim_up'),stand(self))"
	on_end_swim_down_anim="if(underwater,animation('swim_down'),stand(self))"

	on_end_emote_geez_anim="animation('stand')"
	on_end_emote_oh_anim="animation('stand')"
	on_end_emote_impatient_anim="animation('stand')"
	on_end_emote_raisedfinger_anim="animation('stand')"
	on_end_emote_confused_anim="animation('stand')"
	on_end_emote_talk_anim="animation('stand')"

	on_collide_feet="[
	if(IPHONE_SYSTEM, if((not underwater), set(underwater_controls, 0))),
	if(collide_with and collide_with.consts.springiness > 0,
		bounce_on(me, collide_with),
	    [add(velocity_x, -velocity_x/4),
		 if(has_feet and animation != 'spit' and animation != 'jump_attack', if(velocity_y > 1300, animation('land'),stand(self))  )])]"
	on_collide_head="[if(animation = 'jump', animation('bumphead')), if(velocity_y < 0, set(velocity_y, 0))]"
	on_collide="[set(velocity_x, 0), if((animation in ['jump', 'fall']) and can_slide(self) and (abs(velocity_x) > 200 or ctrl_jump and tmp.pressed_jump_in_air), [animation('slide'), set(velocity_y, 0)])]"

	#during the fall spin attack we bounce off enemies that we hit.
	on_collide_object_attack="if(collide_with_area = 'body' and animation = 'fall_spin_attack' and collide_with.consts.springiness > 0 and velocity_y > 0,
	   bounce_on(me, collide_with))"

	##Damage handlers:
	# we have a window of 3 seconds of post-hit invincibility here for all sources of damage
	on_collide_object_body=" if( collide_with_area = 'attack' and ((not collide_with.spat_out_at) or collide_with.spat_out_at < level.cycle - 20) and collide_with.vars.team != vars.team and collide_with.vars.damage > 0,
		  if((not is_invincible(self)),
		  [ 
			add(hitpoints, -collide_with.vars.damage),
			animation(if(FAT, 'spit', 'hurt')),
			set(green, 100), set(blue, 100),
			set(velocity_y,-1000), set(velocity_x,400 * collide_with.facing),
			set(tmp.time_last_hit, cycle),
			set(solid_dimensions_in, ['player'])],
			
			#avoiding being hit due to being invincible. if we have a shield,
			 we make it flash#
			 if(tmp.shield, fire_event(tmp.shield, 'flash'))
			),

			#see if we're colliding with another object's interact area, in which case
			 we set it so we can interact with them.#
			if(collide_with_area = 'interact', set(can_interact, 2))
			)"

	on_collide_object_grab="[if(collide_with_area = 'body' and (not vars.swallowed),
	            if(collide_with.tags.swallowable and collide_with.consts.size <= consts.max_swallow_size,
	                        [remove_object(collide_with),
	  if(animation in ['attack', 'jump_attack', 'up_attack'], set(attached_objects, [collide_with])),
	  [set(collide_with.vars.removed_from_play, 1),sound('Slurp.wav')],
	  set(vars.swallowed, collide_with), fire_event(collide_with, 'swallowed'),
	  add(variations, ['fat'])],
	  
	 #object is not swallowable, so do damage to it instead#
	 if(collide_with.get_hit_by, collide_with.get_hit_by(me))
	  ))]"
	
	#if we couldn't return an object to play when spitting it, revert to
	#having it inside us.
	on_add_object_fail="[if(object and vars.swallowed = null(),
	  [set(object.vars.removed_from_play, 1),
	   set(vars.swallowed, object),
	   add(variations, ['fat'])])]"

	on_surface_damage="[fire_event('collide_damage')]"
	on_collide_damage="[if((not is_invincible(self)), [add(hitpoints, -max(1, surface_damage)), animation(if(FAT, 'spit', 'hurt')), set(green, 100), set(blue, 100), set(tmp.time_last_hit, cycle), set(solid_dimensions_in, ['player'])])]"

	#if we change our solid dimensions -- i.e. try to come back from being
	#hurt, and we can't because we're on top of another solid object, then
	#we take more damage
	on_change_solid_dimensions_fail="[add(hitpoints, -1), animation(if(FAT, 'spit', 'hurt')), set(green, 100), set(blue, 100), set(tmp.time_last_hit, cycle)]"

	#we are blocking a thrown object from respawning, so we get hit.
	on_blocking_thrown_object="get_hit_by(null())"

	on_enter_anim="set(tmp.already_hit, [])"

	
	on_hurtflicker="if(green = 100,[set(green, 255), set(blue, 255)], [set(green, 100), set(blue, 100)])"
	on_leave_hurt_anim="[set(green, 255), set(blue, 255)]"
	on_end_hurt_anim="if((not FAT) and underwater, animation('swim_side_idle'), animation('stand'))"

	on_lose_powerup="null()"
	on_get_powerup="null()"


		[particle_system]
		id=invincible_particles
		type=simple
		min_y=0
		max_y=50
		min_x=0
		max_x=40
		spawn_rate=500
		time_to_live=20
			[animation]
			id=sparkle
			image=props/items.png
			rect=139,74,149,84
			frames=4
			pad=3
			duration=6
			[/animation]
			
			[animation]  ##same thing, but skip the first frame
			id=sparkle
			image=props/items.png
			rect=153,74,163,84
			frames=3
			pad=3
			duration=4
			[/animation]
			
			[animation]  ##same thing, but skip the first 2 frames
			id=sparkle
			image=props/items.png
			rect=167,74,177,84
			frames=2
			pad=3
			duration=6
			[/animation]


			[animation]  ##same thing, but skip the first 3 frames
			id=sparkle
			image=props/items.png
			rect=181,74,191,84
			frames=1
			pad=3
			duration=6
			[/animation]
		[/particle_system]
	
	load_variations="fat"

	[object_variation]
	id=powerup_invincible
		[set_str]
		_target="elements.consts"
		powerup_name="'powerup_invincible'"
		powerup_recharge=100
		[/set_str]

		[set_str]
		_target="self"
		on_process="[{on_process}, set(brightness, (wave(cycle*30)+1000)/3 + 255)]"
		on_timer="[{on_timer}, set(invincible, 10), add(vars.powerup_time, -1), if(vars.powerup_time <= 0, [fire_event('lose_powerup'), set(variations, filter(variations, 'v', v != 'powerup_invincible'))])]"
		on_lose_powerup="[set(brightness, 255), set(invincible_particles.spawn_rate, -1)]"
		on_get_powerup="[set(vars.powerup_time, 200), add_particles('invincible_particles')]"
		[/set_str]
	[/object_variation]

	[object_variation]
	id=powerup_shooting
		[set_str]
		_target="elements.consts"
		powerup_name="'powerup_shooting'"
		powerup_recharge=150
		[/set_str]

		[set_str]
		_target=self
		on_timer="[{on_timer},  add(vars.powerup_time, -1), if(vars.powerup_time <= 0, [fire_event('lose_powerup'), set(variations, filter(variations, 'v', v != 'powerup_shooting'))])]"
		on_lose_powerup="[set(vars.has_energy_shot, 0), set(brightness, 255)]"
		on_get_powerup="[set(vars.has_energy_shot, 1), set(vars.powerup_time, 300)]"
		[/set_str]
	[/object_variation]

	[object_variation]
	id=powerup_reflexes
		[set_str]
		_target="elements.consts"
		powerup_name="'powerup_reflexes'"
		powerup_recharge=150
		[/set_str]

		[set_str]
		_target=self
		on_process="[{on_process}, set(level.time_freeze, level.time_freeze + min(50, cycle - tmp.start_powerup, vars.powerup_time/2)*12),
		  screen_flash([0, 64, 32, (((wave(cycle*16)+2000)/16)*min(50, cycle - tmp.start_powerup, vars.powerup_time/2))/50], 1)]"
		on_timer="[{on_timer},  blur(40, 10, 10), set(vars.powerup_time, vars.powerup_time-1), if(vars.powerup_time <= 0, [fire_event('lose_powerup'), set(variations, filter(variations, 'v', v != 'powerup_reflexes'))])]"
		on_lose_powerup="[set(brightness, 255), blur(0, 0, 0)]"
		on_get_powerup="[set(vars.powerup_time, 300), set(level.chars_immune_from_freeze, [me]), set(tmp.start_powerup, cycle)]"
		on_enter_level="[{on_enter_level}, set(level.chars_immune_from_freeze, [me])]"
		[/set_str]
	[/object_variation]

	[object_variation]
	id=fat
		[set_str]
		_target="filter(elements.animation, image = 'characters/frogatto-spritesheet1.png')"
		image="characters/fat-frogatto-spritesheet1.png"
		[/set_str]

		[set_str]
		_target="elements.consts"
		FAT="1"
		jump_power=1200
		jump_boost=80
		jump_glide=20
		[/set_str]

		[set_str]
		_target="filter(elements.animation, id = 'walk')"
		accel_x=1300
		[/set_str]

		[set_str]
		_target="filter(elements.animation, id = 'run')"
		accel_x=1900
		[/set_str]

		[set_str]
		_target="self"
		[/set_str]

	[/object_variation]

		[base:animation]
		image=characters/frogatto-spritesheet1.png
		accel_x=0
		accel_y=80
		pad=3
		body_area=all
		[/animation]
		
		
		[animation]
		id=stand
		duplicates=6
		rect=2,2,33,34
		frames=3
		duration=6
		reverse=yes
		[/animation]

		[animation]
		id=stand	#blink variant
		rect=107,2,138,34
		frames=3
		duration=6
		reverse=yes
		[/animation]

		[animation]
		id=stand_up_slope
		x=212
		y=2
		w=32
		h=35
		frames=3
		duration=6
		reverse=yes
		[/animation]

		[animation]
		id=stand_down_slope
		x=317
		y=2
		w=32
		h=35
		frames=3
		duration=6
		reverse=yes
		[/animation]

		[animation]
		id=lookup
		rect=37,233,68,265
		frames=1
		duration=3
		reverse=yes
		[/animation]

		[animation]
		id=enter_lookup
		rect=2,233,33,265
		frames=1
		duration=3
		reverse=yes
		[/animation]
		
		[animation]
		id=crouch
		solid_area=9,17,23,30
		rect=107,197,138,229
		frames=1
		duration=1
		rotate_on_slope=yes
		[/animation]

		[animation]
		id=enter_crouch
		solid_area=9,17,23,30
		rect=2,197,33,229
		frames=3
		duration=3
		rotate_on_slope=yes
		[/animation]

		[animation]
		id=leave_crouch
		rect=2,197,33,229
		frames=3
		duration=3
		play_backwards=yes
		rotate_on_slope=yes
		[/animation]


		[animation]
		id=roll
		solid_area=8,17,24,30
		sound=roll.ogg
		accel_x=1000
		velocity_x=500
		x=107
		y=197
		w=32
		h=33
		frames=11
		duration=3
		scale=2		
		[/animation]

		
		[animation]
		id=walk
		solid_area=17,18,31,40
		rect=2,110,49,157
		frames=8
		duration=5
		[/animation]

		[animation]
		id=run
		solid_area=17,18,31,40
		x=410
		y=95
		w=48
		h=48
		frames=4
		frames_per_row=2
		duration=5
		[/animation]

		[animation]
		id=skid
		solid_area=17,18,31,40
		x=461
		y=40
		w=48
		h=48
		frames=1
		duration=10
		[/animation]

		[animation]
		id=turn
		x=387
		y=40
		w=32
		h=33
		frames=1
		duration=5
		[/animation]

		[animation]
		id=jump
		solid_area=9,13,23,35
		sound=FrogJump1.ogg,FrogJump2.ogg
		x=2
		y=38
		w=32
		h=48
		frames=2
		duration=6
		[/animation]

		[animation]
		id=bumphead
		sound=bumphead.wav
		solid_area=9,12,23,34
		rect=422,2,453,36
		duration=5
		frames=1
		[/animation]
	
		[animation]
		id=fall
		solid_area=9,13,23,35
		x=72
		y=38
		w=32
		h=48
		duration=12
		frames=2
		[/animation]

		[animation]
		id=land
		sound=bumphead.wav
		solid_area=9,17,23,39
		x=142
		y=38
		w=32
		h=48
		duration=4
		frames=2
		[/animation]

		[animation]
		image=characters/fat-frogatto-spritesheet1.png
		id=swallow
		x=2
		y=269
		w=49
		h=38
		duration=6
		frames=6
		solid_area=6,13,20,35
		[/animation]

		[animation]
		image=characters/fat-frogatto-spritesheet1.png
		id=spit
		x=314
		y=269
		w=34
		h=35
		duration=3
		frames=3
		solid_area=6,8,20,30
		[/animation]

		[animation]
		id=attack
		sound=tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav
		events="3:side_attack_fx_one,6:side_attack_fx_two,9:side_attack_fx_three,8:side_attack_contact"
		
		x=2
		y=269
		w=26
		h=37
		solid_area=7,12,21,34
		grab_area=32,24,49,34
		body_area=6,11,24,36
		frames=8
		duration=2
		reverse=no
		pad=26
		[/animation]

		[animation]
		id=up_attack
		sound=tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav
		events="6:up_attack_contact"
		x=2
		y=351
		w=41
		h=44
		
		solid_area=7,19,21,41
		grab_area=16,0,28,10
		body_area=0,18,41,44
		frames=6
		duration=2
		reverse=no
		[/animation]

		[animation]
		id=run_attack
		events="6:7:8:9:10:11:run_attack_contact"
		sound=slash.ogg

		solid_area=18,6,32,28
		accel_x=3200
		x=2
		y=403
		w=68
		h=29
		attack_area=20,14,70,40
		body_area=0,0,30,40
		frames=5
		duration=3
		reverse=no
		[/animation]

		[animation]
		id=jump_attack
		events="3:side_attack_fx_one,6:side_attack_fx_two,9:side_attack_fx_three,8:side_attack_contact"
		sound=tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav
		x=2
		y=310
		w=26
		h=37
		grab_area=28,19,43,31
		body_area=6,11,24,36
		frames=9
		duration=2
		reverse=no
		pad=27
		[/animation]

		[animation]
		id=fall_spin_attack
		events="3:6:9:12:15:18:21:24:spin_attack_contact"
		sound=SpinAttack.ogg
		x=3
		y=436
		w=32
		h=42
		attack_area=solid:13,30,23,42
		frames=8
		duration=3
		reverse=no
		[/animation]

		[animation]
		id=hurt
		sound=TakeDamage.wav
		velocity_x=-1000
		velocity_y=-1000
		rect=271,351,303,383
		frames=1
		duration=18
		events="6:12:18:hurtflicker"
		[/animation]

		[animation]
		id=interact
		image=characters/frogatto-spritesheet1.png
		collide_x=10
		collide_y=6
		collide_w=15
		collide_h=16
		feet_x=16
		feet_y=32
		accel_y=80
		x=72
		y=161
		w=32
		h=32
		frames=4
		duration=4
		scale=2
		pad=3
		reverse=yes
		events="15:interacting"
		[/animation]



		[animation]
		id=slide
		image=characters/frogatto-spritesheet1.png
		accel_y=10
		x=352
		y=40
		w=32
		h=34
		duration=30
		frames=1
		solid_area=14,8,28,30
		[/animation]


		[animation]
		id=push
		image=characters/frogatto-spritesheet2.png
		x=413
		y=49
		w=47
		h=48
		frames=6
		frames_per_row=2
		duration=5
		[/animation]





		[animation]
		id=swim_side_idle
		image=characters/frogatto-spritesheet2.png
		accel_y=0
		x=3
		y=85
		w=39
		h=36
		frames=6
		frames_per_row=3
		duration=6
		reverse=yes
		[/animation]

		[animation]
		id=swim_down_idle
		image=characters/frogatto-spritesheet2.png
		accel_y=0
		x=129
		y=85
		w=39
		h=36
		frames=6
		frames_per_row=3
		duration=6
		reverse=yes
		[/animation]

		[animation]
		id=swim_up_idle
		image=characters/frogatto-spritesheet2.png
		accel_y=0
		x=255
		y=85
		w=39
		h=36
		frames=6
		frames_per_row=3
		duration=6
		reverse=yes
		[/animation]

		[animation]
		id=swim_side
		image=characters/frogatto-spritesheet2.png
		sound=Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg
		accel_y=0
		accel_x=0
		x=3
		y=163
		w=39
		h=36
		frames=3
		duration=6
		[/animation]

		[animation]
		id=swim_down
		image=characters/frogatto-spritesheet2.png
		sound=Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg
		accel_x=0
		accel_y=0
		x=129
		y=163
		w=39
		h=36
		frames=3
		duration=6
		[/animation]

		[animation]
		id=swim_up
		image=characters/frogatto-spritesheet2.png
		sound=Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg
		accel_x=0
		accel_y=0
		x=255
		y=163
		w=39
		h=36
		frames=3
		duration=6
		[/animation]



		[animation]
		id=energyshot
		image=characters/frogatto-spritesheet2.png
		rect=3,202,43,245
		frames=2
		frames_per_row=1
		duration=6
		solid_area=6,14,20,36
		[/animation]

		[animation]
		id=energyshot_jump
		image=characters/frogatto-spritesheet2.png
		rect=47,202,87,245
		frames=2
		frames_per_row=1
		duration=5
		[/animation]

		[animation]
		id=up_energyshot
		image=characters/frogatto-spritesheet2.png
		rect=91,202,131,245
		frames=2
		frames_per_row=1
		duration=5
		solid_area=12,14,26,36
		[/animation]

		[animation]
		id=energyshot_down
		rect=135,202,175,245
		image=characters/frogatto-spritesheet2.png
		frames=2
		frames_per_row=1
		duration=5
		[/animation]

		[animation]
		id=energyshot_crouch
		solid_area=6,14,20,27
		rect=179,202,219,245
		image=characters/frogatto-spritesheet2.png
		frames=2
		frames_per_row=1
		duration=8
		[/animation]

		[animation]
		id=energyshot_swim_side
		rect=307,202,345,237
		accel_y=0
		accel_x=0
		image=characters/frogatto-spritesheet2.png
		frames=2
		frames_per_row=1
		duration=8
		[/animation]

		[animation]
		id=energyshot_swim_down
		rect=265,202,303,237
		accel_y=0
		accel_x=0
		image=characters/frogatto-spritesheet2.png
		frames=2
		frames_per_row=1
		duration=8
		[/animation]

		[animation]
		id=energyshot_swim_up
		rect=223,202,261,237
		accel_y=0
		accel_x=0
		image=characters/frogatto-spritesheet2.png
		frames=2
		frames_per_row=1
		duration=8
		[/animation]




		[animation]
		id=emote_geez
		rect=1,1,32,33
		image=characters/frogatto-spritesheet3.png
		frames=8
		reverse=yes
		duration=6
		[/animation]
		
		[animation]
		id=emote_oh
		rect=1,1,32,33
		image=characters/frogatto-spritesheet4.png
		frames=15
		frames_per_row=5
		duration=6
		[/animation]

		[animation]
		id=emote_confused
		rect=1,40,32,72
		image=characters/frogatto-spritesheet3.png
		frames=14
		frames_per_row=7
		duration=6
		[/animation]

		
		[animation]
		id=emote_impatient
		rect=286,1,317,33
		image=characters/frogatto-spritesheet3.png
		frames=16
		frames_per_row=4
		duration=6
		[/animation]
		
		[animation]
		id=emote_raisedfinger
		rect=1,116,32,148
		image=characters/frogatto-spritesheet3.png
		frames=14
		frames_per_row=7
		duration=6
		[/animation]
		
		[animation]
		id=emote_talk
		rect=1,189,32,221
		image=characters/frogatto-spritesheet3.png
		frames=16
		frames_per_row=8
		duration=6
		[/animation]
		
		[animation]
		id=emote_nod
		rect=286,150,317,182
		image=characters/frogatto-spritesheet3.png
		frames=16
		frames_per_row=4
		duration=6
		[/animation]

		[object_variation]
		id=upgrade_shield
			[set_str]
			_target="self"
			on_enter_enter_crouch_anim="if((not tmp.shield),
			    [if(invincible < 25, set(invincible, 25)),
				 add_object(shield_obj), set(tmp.shield, shield_obj),
				 schedule(50, set(tmp.shield, null()))]
				  where shield_obj = object('frogatto_playable.shield', x+30, y+30, 1))"
			[/set_str]
		[/object_variation]

		[object_type]
		id=shield
		on_end_normal_anim="die()"
		on_end_flash_anim="die()"
		on_process="if(cycle < 20, set(alpha, cycle*4), set(alpha, 80 - (cycle-20)*14))"
		on_flash="[set(animation, 'flash'), set(time_in_animation, time_in_animation)]"
			[animation]
			id=normal
			image=characters/frogatto-spritesheet1.png
			frames=1
			duration=25
			rect=286,439,317,471
			[/animation]
			[animation]
			id=flash
			image=characters/frogatto-spritesheet1.png
			frames=1
			duration=25
			rect=321,439,352,471
			[/animation]
		[/object_type]

		[object_type]
		id=tongue_shaft
			[properties]
			set_length="def(len) [set(me.draw_area, [0, 0, len/2, 4]), set(me.tmp.length, len)]"
			[/properties]

			[tmp]
			length=4
			[/tmp]

			[animation]
			image=characters/frogatto-tongue.png
			area=0,0,8,4
			frames=1
			[/animation]
		[/object_type]

		[object_type]
		id=tongue_tip
		solid_dimensions=player,common,boss,thrown

		on_resolve_collide_level="if(collides_with_level(me) and tmp.tongue_shaft.tmp.length > 1,
		                            [add(x, -facing*2),
									 tmp.tongue_shaft.set_length(tmp.tongue_shaft.tmp.length-2),
									 if(facing < 0, add(tmp.tongue_shaft.x, 2)),
									 fire_event('resolve_collide_level')])"

		on_calculate_position="[if(vars.swallowed, [add(vars.swallowed.x, x - last_x),
		                                 add(vars.swallowed.y, y - last_y)]),
		                set(last_x, x), set(last_y, y),
						if(collides_with_level(me),
						  [fire_event('resolve_collide_level'),
						   set(tmp.hit, 1)])]"
		on_collide_object_grab="[if(collide_with_area = 'body' and (not vars.swallowed) and collide_with.vars.team != vars.team,
	            [set(tmp.hit, 1),
				 if(collide_with.tags.swallowable and collide_with.consts.size <= consts.max_swallow_size,
	                        [remove_object(collide_with),
	  set(attached_objects, [collide_with]),
	  [set(collide_with.vars.removed_from_play, 1),sound('Slurp.wav')],
	  set(vars.swallowed, collide_with), fire_event(collide_with, 'swallowed')],
	  
	 #object is not swallowable, so do damage to it instead#
	 if(collide_with.get_hit_by, collide_with.get_hit_by(me))
	  )])]"
	  		[vars]
			swallowed="null()"
			damage=0
			team="'player'"
	  		[/vars]
			[tmp]
			hit=0
			last_x=null()
			last_y=null()
			tongue_shaft=null()
			[/tmp]
			[consts]
			max_swallow_size=16
			[/consts]
			[animation]
			id=normal
			image=characters/frogatto-spritesheet1.png
			frames=1
			duration=100
			rect=197,289,205,295
			grab_area=all
			[/animation]
		[/object_type]

		
	[/object_type]
