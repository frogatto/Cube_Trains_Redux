	[object_type]
	id=frogatto_playable
	prototype=playable
	hitpoints=4
	mass=5
	friction=2000
	solid_area=9,8,23,30
	traction_in_water=1000
	affected_by_currents=yes
	feet_width=5

	#this spritesheet gets switched for fat frogatto, so we can't compile it.
	no_compile_image="characters/frogatto-spritesheet1.png,characters/frogatto-spritesheet3.png,characters/frogatto-spritesheet4.png"

		[editor_info]
		category=player
		[/editor_info]

		[properties]
		
	### attack/damage handlers
		flinch_threshold=0
		team="'player'"
		attack_knockback="if(animation = 'run_attack', 300, 20)"
		damage_cooldown=10
		attack_damage="if(animation = 'fall_spin_attack', 1, 0)"
		damage_type="if(animation = 'run_attack','stun')"

		display_hurt_visuals="def() execute(me, [ animation(if(FAT, 'spit', 'hurt')), hurt_flash_sequence()])"

	### general handlers
		is_player_body_part=1
	
		set_light_size = "def(lsize) [set(vars.lightSize, lsize), fire_event(self, 'light_size')]"
		
		bounce_on="def(object_type frog, obj)
			[set(frog.velocity_y, -max(obj.consts.spring_amount,
						(((frog.velocity_y*obj.consts.springiness)/100)*
							(100 - abs(bounce_angle)))/100)),
			add(frog.velocity_x, (((frog.velocity_y*obj.consts.springiness)/100)*bounce_angle)/100),
			[fire_event(obj, 'bounced_on'),
			set(vars.bounced_on_chain, vars.bounced_on_chain + 1),
			if(obj.team != 'evil', set(vars.bounced_on_chain, 0)),
			#debug(vars.bounced_on_chain + 1),#
			if(vars.bounced_on_chain > 8, achievement('jackalope')),
			],
			if(frog.animation = 'fall_spin_attack', [fire_event(obj, 'stomped_on'),
			set(vars.bounced_on_chain,0),
			])
			]
			where bounce_angle = (obj.consts.bounce_roundness*(frog.midpoint_x - obj.midpoint_x))/(max(1, obj.w))"

		#cheat code:  in the spirit of early cheat codes, this is meant to make testing later levels more balanced against how powerful the player would normally be on such a level; it immediately empowers the player as though the player has purchased a bunch of late game upgrades.  This way we don't fall into making the levels easy enough to pass on a mere 2 hearts.
		#
		#note that the way to enter this code is to type ctrl+d to bring up the debug prompt, type "hax", press return to execute the code, and then press escape to turn off the debug prompt.
		hax="[set(level.player.driver.max_hitpoints, 10), set(level.player.driver.hitpoints, 10),
		set(level.player.driver.spit_power, 160), set(level.player.driver.tongue_length, 22),
		set(level.player.driver.unlocked_items, level.player.driver.unlocked_items + ['powerup_invincible'] + ['powerup_reflexes'])]"

		maintain_locomotion="def() [if(ctrl_left, set(accel_x,1600)), if(ctrl_right, set(accel_x,1600))]"




	#NOTE: regarding channelled attacks, especially those which consume a low amount of mana per frame.
		# Problem:  if your only requirement to initiate the attack is the mana/frame cost, then you will "sputter" when your mana is low.  For example, if it takes 20 mana to fire a round, and it takes 10 frames to recharge that much (say, recharging 2 mana/frame), you'll go from firing a constant steam of one projectile/frame, to firing only one projectile every 10 frames 
		# Visually, this actually looks kinda cool on the fire attack, but it's problematic, because the high cooldown means that this sputtering version is as effective as the real thing even if you have no mana!
		# There are a few options to prevent this, we've gone with #1 for now:
		# 1] when mana is exhausted, incur a "mana shock" timeout where all mana-based abilities are unuseable for a few moments.
		# 2] incur a startup cost to initiate the ability at all; if something costs 2 mana/frame, maybe charge 40 mana to start the ability up at all.
		# 3] rather than a startup cost, require the player to have at least > X mana to use the ability.  This differs from 2] in not actually consuming that startup cost, just requiring you to have it.

		add_mana="def(delta) [set(vars.mana, newValue),if(newValue = 0, set(vars.mana_shock_cycle,cycle))] where newValue = max(0,min(vars.max_mana,vars.mana + delta))"

		mana_shock_active="cycle - vars.mana_shock_cycle < mana_shock_duration"
		mana_shock_duration="150"
		mana_shock_guard="def(thingToDo) if(not mana_shock_active, thingToDo)"

		attack="def()
				if('fat' in variations, tongue(), 
					if(underwater, shoot_bubble(),
						switch(vars.ability_list[vars.current_ability],
							'tongue', tongue(),
							'firebreath', mana_shock_guard(shoot_fire()),
							'energyshot', mana_shock_guard(shoot_energy_shot())
						)
					
				))"

		spawn_tongue="def(angle)
			[if(animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'enter_lookup', 'lookup','skid', 'land'], animation('attack')),
			if(animation in ['jump', 'fall'], animation('jump_attack')),
			spawn('frogatto_playable.tongue_tip', if(facing > 0, x + 30, x), y + 46, facing,set_var('tongue_angle',angle))]"


		tongue="def()
			if(tmp.ctrl_tongue > 1, null(),
				if('fat' in variations,
					if(not (animation in ['interact']), [animation('spit')]),
					[
						if(animation in ['run'], animation('run_attack')),
						if(animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'enter_lookup', 'lookup','skid', 'land', 'jump', 'fall'],
							if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_up, spawn_tongue(-45),
								if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_down, spawn_tongue(45),
									if(ctrl_up, spawn_tongue(-90), if(ctrl_down, spawn_tongue(90), spawn_tongue(0))))))
					]
				)
			)"
		
		shoot_bubble="def() 
			if(cycle%8=0,	[spawn('frogatto_playable.bubble_shot',midpoint_x+10*facing,midpoint_y,facing, [set(velocity_x,(400+1d100)*facing),set(velocity_y,1d100-50)])])"
		
		shoot_fire_active="tmp.ctrl_tongue > 1 and (not animation in ['enter_crouch', 'crouch']) and (not mana_shock_active) and (animation in ['firebreath_begin','firebreath_cycle','firebreath_end'])"
		
		shoot_fire="def() [if((not (shoot_fire_active)) and (not animation in ['enter_crouch', 'crouch']), animation('firebreath_begin')), shoot_fire_internal()]"
		
		shoot_fire_internal="def() if(
		animation in ['firebreath_begin','firebreath_cycle','firebreath_end'] and vars.mana >= mana_cost, [spawn('frogatto_playable.fire_shot',midpoint_x+1d10*facing,midpoint_y+4,facing, 
			[set(velocity_x,(1500+1d250)*facing),set(velocity_y,1d900-450), add_mana(-mana_cost)])]) where mana_cost = 20"
		
		shoot_energy_shot="def() 
			if(energyshot_charge >= energyshot_charge_time and vars.mana >= mana_cost and (not animation in energyshot_anim_list), [set(tmp.start_energyshot_cycle, cycle), schedule(1,animation(energyshot_anim)) ,energyshot_fire_projectile(energyshot_angle), energyshot_spawn_head(), add_mana(-mana_cost)]) where mana_cost = 800"

	
		energyshot_fire_projectile="def(angle) spawn('frogatto_playable.energyshot', midpoint_x + 45*facing*cos(angle), midpoint_y + 40*sin(angle), facing, [set(velocity_x, velocity_x/4 + 2000 * cos(angle) * facing), set(velocity_y, velocity_y/4 + 2000 * sin(angle))])"
				
				
		energyshot_angle="
			if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_up, -45,
				if(((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left)) and ctrl_down, 45,
					if(ctrl_up, -90, if(ctrl_down, 90, 0))))"

		energyshot_spawn_head="def() spawn('frogatto_playable.frogatto_head_energyshot',midpoint_x,midpoint_y-8,facing, [set_var('angle',energyshot_angle)])"

		energyshot_anim="
		switch(1,
			me.animation in ['stand', 'leave_crouch', 'stand_up_slope', 'stand_down_slope', 'walk', 'enter_lookup', 'lookup','skid', 'land'], if(abs(slope_standing_on) < 20, 'energyshot', if(slope_standing_on*facing > 0, 'energyshot_down_slope', 'energyshot_up_slope')),
			me.animation in ['jump', 'fall'], 'energyshot_jump',
			'energyshot')"

		energyshot_charge="min(energyshot_charge_time, cycle - tmp.start_energyshot_cycle)"
		energyshot_anim_list="['energyshot','energyshot_up','energyshot_down','energyshot_jump','energyshot_crouch','energyshot_swim_side','energyshot_swim_down','energyshot_swim_up']"

		energyshot_charge_time=20


		store_event_add="def(event_name, addend) set(level.player.stored_events, map_merge(level.player.vars.stored_events, {event_name -> addend}))" 
		store_event="def(event_name, value) add(level.player.vars.stored_events, {event_name -> value})"
		[/properties]

		on_display_gold="[ if( (cycle - vars.last_got_gold > 20) and (vars.gold_counter > 0), [spawn('text_flash',midpoint_x,midpoint_y-20,1,[set_var('txt','+'+vars.gold_counter)]), set(vars.gold_counter,0)], schedule(10,fire_event('display_gold')))]"

 		[consts]
		JUMP_OUT_OF_WATER_BOOST=1400
		JUMP_OUT_OF_WATER_BOOST_HORIZONTAL=200
		FAT=0
		max_swallow_size=16
		powerup_name=''
		powerup_recharge=0
		posthit_invicibility_period=100    
		[/consts]

		[vars]
		levels_visited="[]"
		enemies_tasted="[]"
		powerup_time=0
		swim_accel=140
		unlocked_items="['heart_object','points_cube','points_cube']"
		next_unlocked_item="null()"
		lightSize=60
		coins=0
		stored_events="{}"
		items_owned="[]"
		jump_power=1200
		jump_boost=90
		jump_glide=30
		walk_accel=1600
		run_accel=2800
		num_partial_hearts=0
		name="'Frogatto'"
		current_ability="0"
		ability_list="['tongue','firebreath','energyshot']"
		mana=5000
		max_mana=5000
		mana_shock_cycle=-150

		swallowed="null()"
		achievement_kill_chain=[[null,-1000], [null,-2000], [null,-3000], [null,-4000], [null,-4000], [null,-5000], [null,-6000], [null,-7000], [null,-8000], [null,-9000], [null,-10000], [null,-11000], [null,-12000], [null,-13000], [null,-14000], [null,-15000]]

		tongue_length=14

		spit_power=80
		[/vars]

		[tmp]
		start_attack_cycle=0
		running=0
		last_shield=0
		shield="null()"
		no_flinch_attack=0

		tongue_tip="null()"
		tongue_shaft="null()"

		#indicates whether the last press of jump was while in the air.
		pressed_jump_in_air="0"
		[/tmp]

	functions="%PROTO%;
	  #function which returns true if the object is in an animation that
	   requires frogatto be on the ground#	
	  def animation_requires_standing(object_type obj)
	    obj.animation in ['stand', 'stand_up_slope', 'stand_down_slope', 'run', 'walk', 'land', 'lookup', 'crouch', 'enter_crouch', 'leave_crouch', 'turn', 'roll','skid'];
	  def set_facing(object_type obj, facing) if(obj.facing != facing and (not (obj.animation in ['interact', 'slide'])),
	           [facing(facing), if(obj.is_standing, animation('turn'))]);

	  def stand(object_type obj)
	   if(abs(obj.velocity_x) > 240 and (not obj.animation in ['walk']), animation('skid'),
	     if(abs(obj.slope_standing_on) < 20, if(not obj.animation in ['stand'], animation('stand')),
		   if(obj.slope_standing_on*obj.facing > 0, animation('stand_down_slope'),
			                                animation('stand_up_slope'))));


	  #make Frogatto walk. anim can be either 'walk' or 'run'. Does checking
	   to make sure Frogatto is in a state where he can walk or run.
	   Will make Frogatto 'glide' if in mid air.#
	  def walk(object_type obj, dir, anim)
	    if(obj.is_standing and (not (obj.animation in ['walk', 'run', 'jump', 'fall', 'jump_attack', 'turn', 'run', 'crouch', 'enter_crouch', 'roll', 'run_attack', 'energyshot', 'attack', 'walk_attack', 'up_attack', 'firebreath_begin','firebreath_cycle','firebreath_end','interact', 'spit'])), [animation(anim), if(anim = 'run', [sound('run.wav')])],
	       #Frogatto is in the air, so make him glide.#
		   if(((not obj.is_standing) and (not (obj.animation in ['slide', 'swim_up', 'swim_down', 'swim_side']))), add(obj.velocity_x, obj.vars.jump_glide*dir)));

	  #Function to attempt to make Frogatto crouch; does checking to make
	   sure he's in a state that allows entering a crouch.#
	  def crouch(object_type obj)
	  	if(((not obj.animation in ['crouch', 'enter_crouch', 'roll', 'interact'] ) and obj.is_standing), animation('enter_crouch'));
	  def roll(object_type obj)
	    if( (not FAT) and (obj.animation in ['crouch']) and obj.is_standing, #animation('roll')#0);


	  #Function to enter swimming frames.#
	  def swim(object_type obj,dirx,diry)
	    if(dirx or diry,
		 [
		  if(obj.animation != anim_wanted, animation(anim_wanted)),
		 add(obj.velocity_x, (obj.swim_accel*dirx)/1000),
		 add(obj.velocity_y, (obj.swim_accel*diry)/1000)
		 ])
			where anim_wanted = if(abs(diry) > 500, if(diry < 0, 'swim_up', 'swim_down'), 'swim_side')	
		;

	  #function to decide if frogatto can slide down a wall#
		def can_slide(object_type obj)
		   (not FAT) and
           solid(obj.level, if(obj.facing > 0, obj.solid_rect.x2+1, obj.solid_rect.x-1), (obj.solid_rect.y + obj.solid_rect.y2*2)/3) and
		   (obj.velocity_y < 300 and obj.velocity_y > -1000 or obj.ctrl_jump and obj.tmp.pressed_jump_in_air);


	   def swallowing_object(object_type frog)
	     if(frog.attached_objects, map(frog.attached_objects, 'obj',
	      if(abs(obj.midpoint_x - context.frog.midpoint_x) < 4, set(attached_objects, []), add(obj.midpoint_x, if(obj.midpoint_x > context.frog.midpoint_x, -4, 4)))
		  ));
	   
	   


	  1"

	#give frogatto brief invincibility when we load
	on_load="[if((not lights), set(lights, circle_light(me, vars.lightSize))),
	          set(invincible, 50), set(brightness, 255)]"

	on_create="[set(lights, circle_light(me, vars.lightSize)), animation('stand'),]"
	on_enter_level="[if(not (level.id in vars.levels_visited),
	                 add(vars.levels_visited, [level.id])),
					 animation('stand')#,
					 if(self.hitpoints < 1, achievement('sans_hat'))#]"

	on_load_checkpoint="[if((not lights), set(lights, circle_light(me, vars.lightSize))),
	                     #TODO: Respawn frogatto with partial health, depending on difficulty level#
	                     #set(hitpoints, (max_hitpoints*3)/4),#
	                     set(hitpoints, max_hitpoints),
	                     set(level.player.vars.score, (level.player.vars.score*9)/10),

	                     #make it so that if we had a swallowed object
						  we create a fresh version of the object in our
						  stomach.
						  COMMENTED OUT FOR NOW -- NOT SURE IF THIS IS NEEDED.
	                     if(vars.swallowed,
							[
						    set(vars.swallowed, obj),
							set(obj.vars.removed_from_play, 1),
							fire_event(obj, 'swallowed')
							] where obj = object(vars.swallowed.type,
							                midpoint_x, midpoint_y, facing)
							),#
						 set(vars.powerup_time, 0),
						 fire_event('lose_powerup'),

	                     #remove variations that aren't upgrades#
						 set(variations, filter(variations, 'v', strstr(v, 'upgrade') or v = 'fat')),
						 animation('stand'),
						 set(velocity_x, 0),
						 set(velocity_y, 0),
						 move_to_standing(),
						 set(brightness, 255),
						 schedule(2, fire_event('check_water'))
						 ]"

	#when jumping we have a zorder that puts us in front of certain tiles, so
	#take care of setting the zorder when entering and leaving such animations.
	on_enter_fall_anim="set(zorder, 10)"
	on_enter_fall_spin_attack_anim="[set(zorder, 10), add(velocity_y, 500), set(velocity_x, velocity_x/2), set(tmp.no_flinch_attack, 1)]"
	on_enter_jump_anim="set(zorder, 10)"
	on_enter_jump_attack_anim="set(zorder, 10)"
	on_enter_slide_anim="[set(zorder, 10),
	  if(IPHONE_SYSTEM, set(underwater_controls, 0))]"

	on_leave_interact_anim="fire_event(interacting_with, 'cancel_interaction')"
	on_leave_fall_anim="set(zorder, 0)"
	on_leave_fall_spin_attack_anim="[set(zorder, 0), set(tmp.no_flinch_attack, 0)]"
	on_leave_jump_anim="set(zorder, 0)"
	on_leave_jump_attack_anim="[fire_event('leave_attack_anim'), set(zorder, 0), set(attached_objects, [])]"
	on_leave_slide_anim="[set(zorder, 0), if(ctrl_left, facing(-1)), if(ctrl_right, facing(1))]"

	on_enter_walk_anim="[set(accel_x, vars.walk_accel), set(vars.bounced_on_chain,0),]"
	on_enter_run_anim="[set(accel_x, vars.run_accel), set(vars.bounced_on_chain,0),]"


	on_die="[remove_object(tmp.tongue_tip), remove_object(tmp.tongue_shaft), spawn('die_cloud', midpoint_x, midpoint_y, facing)]"
	on_ctrl_left="[set_facing(self, -1), roll(self), if(tmp.left and tmp.left > cycle - 15 or tmp.running = 1, [walk(self, -1, 'run'), set(tmp.running, 1)]), set(tmp.left, cycle), set(tmp.right, null())]"
	on_ctrl_right="[set_facing(self, 1), roll(self), if(tmp.right and tmp.right > cycle - 15 or tmp.running = 1, [walk(self, 1, 'run'), set(tmp.running, 1)]), set(tmp.right, cycle), set(tmp.left, null())]"
	on_ctrl_jump="[set(tmp.pressed_jump_in_air, (not is_standing)),
				%PROTO%,
	            if(animation = 'slide', [facing(-facing), animation('jump'), set(velocity_x, -facing*800), set(velocity_y, -1000)])]"
	on_light_size="[set(lights, circle_light(me, vars.lightSize))]"

	on_ctrl_down="if(animation = 'slide', animation('fall'))"
	on_ctrl_attack="set(vars.current_ability, (vars.current_ability + 1) % vars.ability_list.size)"

	on_end_ctrl_up="if((animation in ['enter_lookup', 'lookup']), stand(self))"

	timer_frequency=2
	on_timer="[
	    if(ctrl_right - ctrl_left != 0 and ctrl_right - ctrl_left != facing, set_facing(me, -facing)),
	    if(ctrl_up and (animation in ['stand','stand_up_slope','stand_down_slope']), animation('enter_lookup')),

	   %PROTO%]"

	on_start_level="fire_event('check_water')"

	on_process="[
	    if((not is_standing) and animation_requires_standing(self), [animation('fall')]),
		if((not FAT) and underwater and (not (tmp.tongue_tip)),
		  if(IPHONE_SYSTEM,
		    [
			  swim(self, ctrl_x, ctrl_y),
			  if((not ctrl_x) and (not ctrl_y), float(self)),
			  if(ctrl_x < 0 and facing > 0 or ctrl_x > 0 and facing < 0, set(facing, -facing))
			],

			[
			swim(self, (ctrl_right - ctrl_left)*if(ctrl_down or ctrl_up, 700, 1000), (ctrl_down - ctrl_up)*if(ctrl_left or ctrl_right, 700, 1000)),
			if((not (ctrl_left or ctrl_right or ctrl_up or ctrl_down)) and (animation in ['swim_side','swim_up','swim_down']),
		   float(self)) ]
		     ),
		   
		   ),

		   if(ctrl_left, if(tmp.running, walk(self, -1, 'run'), walk(self, -1, 'walk'))),
			if(ctrl_right, if(tmp.running, walk(self, 1, 'run'), walk(self, 1, 'walk'))),
			if(ctrl_down and (not (ctrl_left or ctrl_right)), crouch(self)),
			
			if(ctrl_tongue,add(tmp.ctrl_tongue,1),set(tmp.ctrl_tongue,0)),
			if(ctrl_attack,add(tmp.ctrl_attack,1),set(tmp.ctrl_attack,0)),

			if(not mana_shock_active,add_mana(2)),
			if(ctrl_tongue,attack())
			
	]"

	on_process_fall="[
	    if(IPHONE_SYSTEM, if(underwater_controls, [
		         add(velocity_x, (jump_glide*ctrl_x)/1000),
		         add(velocity_y, (jump_glide*ctrl_y)/1000)])),
	    %PROTO%]"

	on_process_lookup="[add(tmp.lookup_time, 1), if(tmp.lookup_time = 50, set(vertical_look, -200))]"
	on_process_crouch="[add(tmp.lookdown_time, 1), if(tmp.lookdown_time = 50, set(vertical_look, 200))]"
	on_leave_lookup_anim="[set(tmp.lookup_time, 0), set(vertical_look, 0)]"
	on_leave_crouch_anim="[set(tmp.lookdown_time, 0), set(vertical_look, 0)]"


	on_process_slide="if(not can_slide(self), animation('fall'))"

	on_check_water="[if(underwater and (not FAT), animation('swim_side')), if(IPHONE_SYSTEM, set(underwater_controls, underwater))]"

	on_enter_water="[
	    if(IPHONE_SYSTEM, set(underwater_controls, 1)),
	    if((not FAT) and (not (tmp.tongue_tip)), [float(self), set(has_feet, 0)]),
		
		sound('water-enter.ogg'),

		#splash if we are entering the water with reasonable velocity#
		if(velocity_y > 200, [
			spawn('water_splash', midpoint_x, water_bounds[1]+10, if(1d2=2,facing,-facing)),
			spawn('water_particles', midpoint_x, water_bounds[1]+10, facing)]),
		#record the surface level of the water for future reference,
		 especially for splashing when we exit the water#
		set(tmp.water_surface, water_bounds[1])]"
	
	on_exit_water="[
	    set(has_feet, 1),
		sound('water-exit.ogg'),
		schedule(60, fire_event('check_water')),

		if(velocity_y < -200,
	      [spawn('water_splash', midpoint_x, tmp.water_surface+10, if(1d2=2,facing,-facing)),
	      spawn('water_particles', midpoint_x, tmp.water_surface+10, facing)]),

	
	animation('fall'), if(velocity_y < 0, add(velocity_y, -JUMP_OUT_OF_WATER_BOOST)),
	set(velocity_x, (velocity_x*JUMP_OUT_OF_WATER_BOOST_HORIZONTAL)/100)
	
	]"
	
	on_end_ctrl_left="[set(tmp.running, 0),
	     if((not (ctrl_left or ctrl_right)) and (animation in ['walk', 'run']), stand(self))]"
	on_end_ctrl_right="[set(tmp.running, 0),
	     if((not (ctrl_left or ctrl_right)) and (animation in ['walk', 'run']), stand(self))]"

	on_end_enter_crouch_anim="animation('crouch')"
	on_end_crouch_anim="if(ctrl_down, animation('crouch'), animation('leave_crouch'))"
	on_end_leave_crouch_anim="stand(self)"
	
	on_enter_skid_anim="if(abs(velocity_x) > 300, spawn('dust_cloud_skid', midpoint_x + 36*facing, y2 - 10, facing))"
	on_enter_land_anim="[spawn('dust_cloud_skid', midpoint_x + 20*facing, y2 - 8, facing), spawn('dust_cloud_skid', midpoint_x - 20*facing, y2 - 8, -facing)]"
	
	on_end_roll_anim="animation('crouch')"
	on_leave_roll_anim="stop_sound('roll.ogg')"
	on_end_turn_anim="stand(self)"
	on_end_jump_anim="animation('fall')"
	on_end_bumphead_anim="animation('fall')"
	on_end_land_anim="stand(self)"
	on_end_walk_anim="animation('walk')"
	on_end_run_anim="[animation('run'),  if(abs(velocity_x) > 300, spawn('dust_cloud_run', midpoint_x + 30*facing, y2 - 12, -facing))]"
	
	#note:  using level.zoom to detect if in a cutscene or dialogue, in which case we don't do idle anims.
	#TODO:  this fails to account for the epilogue.  Figure out some way to do this without setting a special tracker variable, since those are bugprone.
	on_end_stand_anim="if((not FAT) and (tmp.idleness_counter >=9) and level.zoom = 1, 
									[fire_event('idling'), set(tmp.idleness_counter, 0)],
									[animation('stand'), add(tmp.idleness_counter, 1)])"
	on_leave_stand_anim="[set(tmp.idleness_counter, 0), set(tmp.idleness_level, 0)]"
	on_end_skid_anim="stand(self)"
	on_end_stand_up_slope_anim="stand(self)"
	on_end_stand_down_slope_anim="stand(self)"
	
	on_idling="if(tmp.idleness_level < 3, 
					[switch(1d3,
						1, animation('stand'),
						2, animation('stand'),
						3, animation('stand')
						),
					add(tmp.idleness_level, 1)
					],
					[switch(1d3,
						1, animation('idle_eyeball'),
						2, animation('idle_eyeball'),
						3, animation('idle_eyeball')
						),
					set(tmp.idleness_level, 0)
					])"
	on_end_idle_eyeball_anim="stand(self)"

	on_footfall="sound('footstep'+1d4+'.wav')"

	on_enter_spit_anim="[set(tmp.spit_force, 0), set(variations, filter(variations, 'v', v != 'fat'))]"
	on_process_spit="[if(ctrl_attack or ctrl_tongue, add(tmp.spit_force, 1)),maintain_locomotion()]"
	on_end_spit_anim="if(underwater, float(self), stand(self))"
	on_leave_spit_anim="if(vars.swallowed, [
	     set(green, 255), set(blue, 255),
		 add(gravity_shift, -vars.swallowed.vars.swallow_gravity),
	     set(vars.swallowed.vars.removed_from_play, 0),
	     set(vars.swallowed.velocity_x, velocity_x + facing*(200 + tmp.spit_force*if(ctrl_up, vars.spit_power/2, vars.spit_power*2))),
	     set(vars.swallowed.velocity_y, velocity_y - (600 + if(ctrl_up, 200 + tmp.spit_force*vars.spit_power))),

	     #set the object's timestamp for when it was spat out, so we
		  can make ourselves invincible to it for a little while#
		 set(vars.swallowed.time_spat, level.cycle),
		 set(vars.swallowed, null()),

         #set the enemy to be dimensionless, meaning it will only collide
		  with the level. If it collides with another object we expect
		  it to die.#
	     set(vars.swallowed.solid_dimensions_in, ['thrown']),
		 if(vars.swallowed.consts.thrown_type, set(vars.swallowed.type, vars.swallowed.consts.thrown_type)),
		 set(vars.swallowed.animation, 'thrown'),
		 
		 set(vars.swallowed.midpoint_x, midpoint_x),
		 set(vars.swallowed.y, y),
		 resolve_solid(vars.swallowed, facing, 0, 50),
		 resolve_solid(vars.swallowed, -facing, 0, 50),

	     add_object(vars.swallowed),
		 fire_event(vars.swallowed, 'spat'),
		 if(underwater, set(has_feet, 0)),
		 sound('Spit.wav')
		 ])"
	
	on_child_spawned="if(child.type = 'frogatto_playable.tongue_tip',
	                  [set(tmp.tongue_tip, child), set(child.tmp.frog, me)])"
	

	on_process_attack="if((facing = 1 and ctrl_right) or (facing = -1 and ctrl_left), [set(animation, 'walk_attack'), set(time_in_animation, time_in_animation),set(accel_x, vars.walk_accel)])"
	on_process_walk_attack="if((facing = 1 and (not (ctrl_right))) or (facing = -1 and (not (ctrl_left))), [set(animation, 'attack'), set(time_in_animation, time_in_animation)])"
	on_end_walk_attack_anim="animation('walk')"

	

	
	on_end_energyshot_anim="stand(self)"
	on_end_energyshot_jump_anim="stand(self)"
	on_end_energyshot_up_slope_anim="stand(self)"
	on_end_energyshot_down_slope_anim="stand(self)"

	on_end_attack_anim="[
		 if(('fat' in variations), animation('swallow')),
	                               stand(self)]"
	on_leave_attack_anim="[if(tmp.tongue_tip, fire_event('remove_tongue')), set(attached_objects, [])]"
	on_leave_up_attack_anim="set(attached_objects, [])"
	on_end_swallow_anim="stand(self)"
	on_end_enter_lookup_anim="animation('lookup')"
	on_end_lookup_anim="animation('lookup')"
	on_end_run_attack_anim="[animation('skid'), set(tmp.running, 0)]"
	on_end_up_attack_anim="stand(self)"
	on_end_jump_attack_anim="animation('fall')"
	on_end_fall_spin_attack_anim="animation('fall')"
	on_end_firebreath_begin_anim="animation('firebreath_cycle')"
	on_end_firebreath_cycle_anim="if(shoot_fire_active,animation('firebreath_cycle'),animation('firebreath_end'))"
	on_end_firebreath_end_anim="stand(self)"
	on_end_swim_side_idle_anim="float(self)"
	on_end_swim_side_anim="if(underwater,animation('swim_side'),stand(self))"
	on_end_swim_up_anim="if(underwater,animation('swim_up'),stand(self))"
	on_end_swim_down_anim="if(underwater,animation('swim_down'),stand(self))"

	on_end_emote_geez_anim="animation('stand')"
	on_end_emote_oh_anim="animation('stand')"
	on_end_emote_impatient_anim="animation('stand')"
	on_end_emote_raisedfinger_anim="animation('stand')"
	on_end_emote_confused_anim="animation('stand')"
	on_end_emote_talk_anim="animation('stand')"
	on_end_emote_nod_anim="animation('stand')"

	on_collide_feet="[
	if(IPHONE_SYSTEM, if((not underwater), set(underwater_controls, 0))),
	if(collide_with and collide_with.consts.springiness > 0,
		bounce_on(me, collide_with),
	    [set(velocity_x, velocity_x/2),
		 if(has_feet and animation != 'spit' and animation != 'jump_attack', if(velocity_y > 1300, animation('land'),stand(self))  )])]"
	on_collide_head="[if(animation = 'jump', animation('bumphead')), if(velocity_y < 0, set(velocity_y, 0))]"
	on_collide_side="[set(velocity_x, 0), if((animation in ['jump', 'fall']) and can_slide(self) and (abs(velocity_x) > 200 or ctrl_jump and tmp.pressed_jump_in_air), [animation('slide'), set(velocity_y, 0)])]"

	#during the fall spin attack we bounce off enemies that we hit.
	on_collide_object_attack="if(collide_with_area = 'body' and animation = 'fall_spin_attack' and collide_with.consts.springiness > 0 and velocity_y > 0,
	   bounce_on(me, collide_with))"


	on_collide_object_body=" if( collide_with_area = 'attack' and ((not collide_with.spat_out_at) or collide_with.spat_out_at < level.cycle - 20) and collide_with.team != team,
				if(not is_invincible, get_hit_by(collide_with),  if(tmp.shield, fire_event(tmp.shield, 'flash'))),
				
				#if it wasn't the attack area that hit our body, respond to other areas#
				#see if we're colliding with another object's interact area, in which case#
				 #we set it so we can interact with them.#
			if(collide_with_area = 'interact', set(can_interact, 2))
			)"



	on_collide_object_grab="[if(collide_with_area = 'body' and (not vars.swallowed),
	            if(collide_with.tags.swallowable and collide_with.consts.size <= consts.max_swallow_size,
	                        [remove_object(collide_with),
	  if(animation in ['attack', 'jump_attack', 'up_attack'], set(attached_objects, [collide_with])),
	  [set(collide_with.vars.removed_from_play, 1),sound('Gulp.wav')],
	  set(vars.swallowed, collide_with), fire_event(collide_with, 'swallowed'),
	  add(gravity_shift, collide_with.vars.swallow_gravity),
	  add(variations, ['fat'])],
	  
	 #object is not swallowable, so do damage to it instead#
	 if(collide_with.get_hit_by, collide_with.get_hit_by(me))
	  ))]"
	
	#if we couldn't return an object to play when spitting it, revert to
	#having it inside us.
	on_add_object_fail="[if(object and vars.swallowed = null(),
	  [set(object.vars.removed_from_play, 1),
	   set(vars.swallowed, object),
	   add(gravity_shift, object.vars.swallow_gravity),
	   add(variations, ['fat'])])]"

	#if we change our solid dimensions -- i.e. try to come back from being
	#hurt, and we can't because we're on top of another solid object, then
	#we take more damage
	on_change_solid_dimensions_fail="[%PROTO%,
	          if(not is_invincible_posthit, animation(if(FAT, 'spit', 'hurt')))]"

	
	on_end_hurt_anim="if((not FAT) and underwater, animation('swim_side_idle'), animation('stand'))"

	on_lose_powerup="null()"
	on_get_powerup="null()"


		[particle_system]
		id=invincible_particles
		type=simple
		min_y=0
		max_y=50
		min_x=0
		max_x=40
		spawn_rate=500
		time_to_live=20
			[animation]
			id=sparkle
			image=props/items.png
			rect=139,74,149,84
			frames=4
			pad=3
			duration=6
			[/animation]
			
			[animation]  ##same thing, but skip the first frame
			id=sparkle
			image=props/items.png
			rect=153,74,163,84
			frames=3
			pad=3
			duration=4
			[/animation]
			
			[animation]  ##same thing, but skip the first 2 frames
			id=sparkle
			image=props/items.png
			rect=167,74,177,84
			frames=2
			pad=3
			duration=6
			[/animation]


			[animation]  ##same thing, but skip the first 3 frames
			id=sparkle
			image=props/items.png
			rect=181,74,191,84
			frames=1
			pad=3
			duration=6
			[/animation]
		[/particle_system]
	
	load_variations="fat"

	[object_variation]
	id=powerup_invincible
		[set_str]
		_target="elements.consts"
		powerup_name="'powerup_invincible'"
		powerup_recharge=100
		[/set_str]

		[set_str]
		_target="self"
		on_process="[{on_process}, set(brightness, (wave(cycle*30)+1000)/3 + 255)]"
		on_timer="[{on_timer}, set(invincible, 10), add(vars.powerup_time, -1), if(vars.powerup_time <= 0, [fire_event('lose_powerup'), set(variations, filter(variations, 'v', v != 'powerup_invincible'))])]"
		on_lose_powerup="[set(brightness, 255), set(invincible_particles.spawn_rate, -1)]"
		on_get_powerup="[set(vars.powerup_time, 200), add_particles('invincible_particles')]"
		[/set_str]
	[/object_variation]

	[object_variation]
	id=powerup_reflexes
		[set_str]
		_target="elements.consts"
		powerup_name="'powerup_reflexes'"
		powerup_recharge=150
		[/set_str]

		[set_str]
		_target=self
		on_process="[{on_process}, set(level.time_freeze, level.time_freeze + min(50, cycle - tmp.start_powerup, vars.powerup_time/2)*12),
		  screen_flash([0, 64, 32, (((wave(cycle*16)+2000)/16)*min(50, cycle - tmp.start_powerup, vars.powerup_time/2))/50], 1)]"
		on_timer="[{on_timer},  blur(40, 10, 10), set(vars.powerup_time, vars.powerup_time-1), if(vars.powerup_time <= 0, [fire_event('lose_powerup'), set(variations, filter(variations, 'v', v != 'powerup_reflexes'))])]"
		on_lose_powerup="[set(brightness, 255), blur(0, 0, 0)]"
		on_get_powerup="[set(vars.powerup_time, 300), set(level.chars_immune_from_freeze, [me]), set(tmp.start_powerup, cycle)]"
		on_enter_level="[{on_enter_level}, set(level.chars_immune_from_freeze, [me])]"
		[/set_str]
	[/object_variation]

	[object_variation]
	id=fat
		[set_str]
		_target="filter(elements.animation, image = 'characters/frogatto-spritesheet1.png')"
		image="characters/fat-frogatto-spritesheet1.png"
		[/set_str]
		
		[set_str]
		_target="filter(elements.animation, image = 'characters/frogatto-spritesheet3.png')"
		image="characters/fat-frogatto-spritesheet3.png"
		[/set_str]
		
		[set_str]
		_target="filter(elements.animation, image = 'characters/frogatto-spritesheet4.png')"
		image="characters/fat-frogatto-spritesheet4.png"
		[/set_str]

		[set_str]
		_target="elements.consts"
		FAT="1"
		jump_power=1200
		jump_boost=80
		jump_glide=20
		[/set_str]

		[set_str]
		_target="filter(elements.animation, id = 'walk')"
		accel_x=1300
		[/set_str]

		[set_str]
		_target="filter(elements.animation, id = 'run')"
		accel_x=1900
		[/set_str]

		[set_str]
		_target="self"
		[/set_str]

	[/object_variation]

		[base:animation]
		image=characters/frogatto-spritesheet1.png
		accel_x=0
		accel_y=80
		pad=3
		body_area=all
		feet_width=5
		[/animation]
		
		
		[animation]
		id=stand
		duplicates=6
		rect=2,2,33,34
		frames=3
		duration=6
		reverse=yes
		[/animation]
		
		[animation]
		id=freeze
		duplicates=6
		rect=2,2,33,34
		frames=3
		duration=100000000
		reverse=yes
		accel_x=0
		accel_y=0
		[/animation]

		[animation]
		id=stand	#blink variant
		rect=107,2,138,34
		frames=3
		duration=6
		reverse=yes
		[/animation]

		[animation]
		id=stand_up_slope
		x=212
		y=2
		w=32
		h=35
		solid_area=9,9,23,31
		frames=3
		duration=6
		reverse=yes
		[/animation]

		[animation]
		id=stand_down_slope
		x=317
		y=2
		w=32
		h=35
		solid_area=9,9,23,31
		frames=3
		duration=6
		reverse=yes
		[/animation]

		[animation]
		id=lookup
		rect=37,233,68,265
		frames=1
		duration=3
		reverse=yes
		[/animation]

		[animation]
		id=enter_lookup
		rect=2,233,33,265
		frames=1
		duration=3
		reverse=yes
		[/animation]
		
		[animation]
		id=crouch
		solid_area=9,17,23,30
		rect=107,197,138,229
		frames=1
		duration=1
		rotate_on_slope=yes
		[/animation]

		[animation]
		id=enter_crouch
		solid_area=9,17,23,30
		rect=2,197,33,229
		frames=3
		duration=3
		rotate_on_slope=yes
		[/animation]

		[animation]
		id=leave_crouch
		rect=2,197,33,229
		frames=3
		duration=3
		play_backwards=yes
		rotate_on_slope=yes
		[/animation]


		[animation]
		id=roll
		solid_area=8,17,24,30
		sound=roll.ogg
		accel_x=1000
		velocity_x=500
		x=107
		y=197
		w=32
		h=33
		frames=11
		duration=3
		scale=2		
		[/animation]

		
		[animation]
		id=walk
		solid_area=17,18,31,40
		rect=2,110,49,157
		frames=8
		duration=5
		events="10:30:footfall"
		[/animation]

		[animation]
		id=run
		solid_area=17,18,31,40
		x=410
		y=95
		w=48
		h=48
		frames=4
		frames_per_row=2
		duration=5
		events="0:10:footfall"
		[/animation]

		[animation]
		id=skid
		solid_area=17,18,31,40
		x=461
		y=40
		w=48
		h=48
		frames=1
		duration=10
		[/animation]

		[animation]
		id=turn
		x=387
		y=40
		w=32
		h=33
		frames=1
		duration=5
		[/animation]

		[animation]
		id=jump
		solid_area=9,13,23,35
		sound=FrogJump1.ogg,FrogJump2.ogg
		x=2
		y=38
		w=32
		h=48
		frames=2
		duration=6
		[/animation]

		[animation]
		id=bumphead
		sound=bumphead.wav
		solid_area=9,12,23,34
		rect=422,2,453,36
		duration=5
		frames=1
		[/animation]
	
		[animation]
		id=fall
		solid_area=9,13,23,35
		x=72
		y=38
		w=32
		h=48
		duration=12
		frames=2
		[/animation]

		[animation]
		id=land
		sound=bumphead.wav
		solid_area=9,17,23,39
		x=142
		y=38
		w=32
		h=48
		duration=4
		frames=2
		[/animation]

		[animation]
		image=characters/fat-frogatto-spritesheet1.png
		id=swallow
		x=2
		y=269
		w=49
		h=38
		duration=6
		frames=6
		solid_area=6,13,20,35
		[/animation]

		[animation]
		image=characters/fat-frogatto-spritesheet1.png
		id=spit
		x=314
		y=269
		w=34
		h=35
		duration=3
		frames=3
		solid_area=6,8,20,30
		[/animation]

		[animation]
		image=characters/frogatto-spritesheet5.png
		id=attack
		sound=tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav
		rect=2,151,33,188
		solid_area=9,12,23,34
		body_area=16,11,30,36
		frames=8
		duration=2
		reverse=no
		[/animation]

		[animation]
		image=characters/frogatto-spritesheet5.png
		id=walk_attack
		
		rect=2,233,33,270
		solid_area=9,12,23,34
		body_area=16,11,30,36
		frames=4
		duration=4
		reverse=no
		[/animation]

		[animation]
		id=run_attack
		events="6:7:8:9:10:11:run_attack_contact"
		sound=slash.ogg

		solid_area=18,6,32,28
		accel_x=3200
		x=2
		y=403
		w=68
		h=30
		attack_area=20,14,70,40
		body_area=0,0,30,40
		frames=5
		duration=3
		reverse=no
		[/animation]

		[animation]
		id=jump_attack
		image=characters/frogatto-spritesheet5.png
		sound=tongueOut1.wav,tongueOut2.wav,tongueOut3.wav,tongueOut4.wav,tongueOut5.wav,tongueOut6.wav
		rect=2,192,50,229
		body_area=6,11,24,36
		solid_area=16,10,30,32
#	solid_area=9,8,23,30
		frames=8
		duration=2
		reverse=no
		[/animation]

		[animation]
		id=firebreath_begin
		rect=286,476,319,510
		frames=3
		duration=2
		[/animation]

		[animation]
		id=firebreath_cycle
		rect=360,476,393,510
		frames=2
		duration=2
		[/animation]

		[animation]
		id=firebreath_end
		rect=286,476,319,510
		frames=3
		duration=2
		play_backwards=yes
		[/animation]
		

		[animation]
		id=fall_spin_attack
		sound=SpinAttack.ogg
		x=3
		y=436
		w=32
		h=42
		attack_area=solid:13,30,23,42
		frames=8
		duration=3
		reverse=no
		[/animation]

		[animation]
		id=hurt
		sound=TakeDamage.wav
		rect=271,351,303,383
		frames=1
		duration=18
		[/animation]

		[animation]
		id=interact
		image=characters/frogatto-spritesheet1.png
		collide_x=10
		collide_y=6
		collide_w=15
		collide_h=16
		feet_x=16
		feet_y=32
		accel_y=80
		x=72
		y=161
		w=32
		h=33
		frames=4
		duration=4
		scale=2
		pad=3
		reverse=yes
		events="15:interacting"
		[/animation]



		[animation]
		id=slide
		image=characters/frogatto-spritesheet1.png
		accel_y=10
		x=352
		y=40
		w=32
		h=34
		duration=30
		frames=1
		solid_area=14,8,28,30
		[/animation]


		[animation]
		id=push
		image=characters/frogatto-spritesheet2.png
		x=413
		y=49
		w=47
		h=48
		frames=6
		frames_per_row=2
		duration=5
		[/animation]





		[animation]
		id=swim_side_idle
		image=characters/frogatto-spritesheet2.png
		accel_y=0
		x=3
		y=85
		w=39
		h=36
		frames=6
		frames_per_row=3
		duration=6
		reverse=yes
		#solid area not set as it would cause collision problems with the level
		#solid_area=8,13,30,27
		[/animation]

		[animation]
		id=swim_down_idle
		image=characters/frogatto-spritesheet2.png
		accel_y=0
		x=129
		y=85
		w=39
		h=36
		frames=6
		frames_per_row=3
		duration=6
		reverse=yes
		solid_area=12,8,26,30
		[/animation]

		[animation]
		id=swim_up_idle
		image=characters/frogatto-spritesheet2.png
		accel_y=0
		x=255
		y=85
		w=39
		h=36
		frames=6
		frames_per_row=3
		duration=6
		reverse=yes
		solid_area=12,8,26,30
		[/animation]

		[animation]
		id=swim_side
		image=characters/frogatto-spritesheet2.png
		sound=Paddle1.ogg,Paddle2.ogg,Paddle3.ogg,Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg
		accel_y=0
		accel_x=0
		x=3
		y=163
		w=39
		h=36
		frames=3
		duration=10
		#solid area not set as it would cause collision problems with the level
		#solid_area=8,13,30,27
		[/animation]

		[animation]
		id=swim_down
		image=characters/frogatto-spritesheet2.png
		sound=Paddle1.ogg,Paddle2.ogg,Paddle3.ogg,Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg
		accel_x=0
		accel_y=0
		x=129
		y=163
		w=39
		h=36
		frames=3
		duration=10
		solid_area=12,8,26,30
		[/animation]

		[animation]
		id=swim_up
		image=characters/frogatto-spritesheet2.png
		sound=Paddle1.ogg,Paddle2.ogg,Paddle3.ogg,Paddle4.ogg,Paddle5.ogg,Paddle6.ogg,Paddle7.ogg
		accel_x=0
		accel_y=0
		x=255
		y=163
		w=39
		h=36
		frames=3
		duration=10
		solid_area=12,8,26,30
		[/animation]




		[animation]
		id=energyshot_jump
		image=characters/frogatto-spritesheet2.png
		rect=1,415,41,458
		frames=2
		frames_per_row=1
		duration=5
		solid_area=12,14,26,36
		[/animation]

		[animation]
		id=energyshot_down_slope
		image=characters/frogatto-spritesheet2.png
		rect=45,415,85,458
		frames=2
		frames_per_row=1
		duration=5
		solid_area=14,15,28,37
		[/animation]

		[animation]
		id=energyshot_up_slope
		image=characters/frogatto-spritesheet2.png
		rect=89,415,129,458
		frames=2
		frames_per_row=1
		duration=5
		solid_area=14,15,28,37
		[/animation]

		[animation]
		id=energyshot
		image=characters/frogatto-spritesheet2.png
		rect=133,415,173,458
		frames=2
		frames_per_row=1
		duration=5
		solid_area=14,14,28,36
		[/animation]


		[animation]
		id=emote_geez
		rect=1,1,36,38
		solid_area=11,13,25,35
		image=characters/frogatto-spritesheet3.png
		frames=8
		reverse=yes
		duration=6
		[/animation]
		
		[animation]
		id=emote_oh
		rect=1,1,36,38
		solid_area=11,13,25,35
		image=characters/frogatto-spritesheet4.png
		frames=15
		frames_per_row=5
		duration=6
		[/animation]

		[animation]
		id=emote_confused
		rect=1,52,36,89
		solid_area=11,13,25,35
		image=characters/frogatto-spritesheet3.png
		frames=14
		frames_per_row=7
		duration=6
		[/animation]

		
		[animation]
		id=emote_impatient
		rect=323,1,358,38
		solid_area=11,13,25,35
		image=characters/frogatto-spritesheet3.png
		frames=16
		frames_per_row=4
		duration=6
		[/animation]
		
		[animation]
		id=emote_raisedfinger
		rect=1,144,36,181
		solid_area=11,13,25,35
		image=characters/frogatto-spritesheet3.png
		frames=14
		frames_per_row=7
		duration=6
		[/animation]
		
		[animation]
		id=emote_talk
		rect=1,236,36,273
		solid_area=11,13,25,35
		image=characters/frogatto-spritesheet3.png
		frames=16
		frames_per_row=8
		duration=6
		[/animation]
		
		[animation]
		id=emote_nod
		rect=323,175,358,212
		solid_area=11,13,25,35
		image=characters/frogatto-spritesheet3.png
		frames=16
		frames_per_row=4
		duration=6
		[/animation]

		[animation]
		id=idle_eyeball
		rect=1,1,34,34
		accel_y=0
		accel_x=0
		image=characters/frogatto-spritesheet-idle.png
		frames=43
		duration=6
		pad=1
		[/animation]

		[object_variation]
		id=upgrade_shield
			[set_str]
			_target="self"
			on_enter_enter_crouch_anim="if((not tmp.shield),
			    [if(invincible < 25, set(invincible, 25)),
				 add_object(shield_obj), set(tmp.shield, shield_obj),
				 schedule(50, set(tmp.shield, null()))]
				  where shield_obj = object('frogatto_playable.shield', x+30, y+30, 1))"
			[/set_str]
		[/object_variation]

		[object_type]
		id=shield
		on_end_normal_anim="die()"
		on_end_flash_anim="die()"
		on_process="if(cycle < 20, set(alpha, cycle*4), set(alpha, 80 - (cycle-20)*14))"
		on_flash="[set(animation, 'flash'), set(time_in_animation, time_in_animation)]"
			[animation]
			id=normal
			image=characters/frogatto-spritesheet1.png
			frames=1
			duration=25
			rect=286,439,317,471
			[/animation]
			[animation]
			id=flash
			image=characters/frogatto-spritesheet1.png
			frames=1
			duration=25
			rect=321,439,352,471
			[/animation]
		[/object_type]

#------------------------- TONGUE/HEAD -------------------------#
		[object_type]
		id=tongue_shaft
		always_active=yes
		serializable=no
		zorder=5
		solid_dimensions=none
			[properties]
				is_player_body_part=1
				myLength="def(x,y,z,a) sqrt(ly^2 + lx^2) where lx = abs(x-z) where ly = abs(y-a)"
				length="myLength(x_1,y_1,x_2,y_2)"
				set_ends="def(new_x1,new_y1,new_x2,new_y2) [set(vars.x_1,new_x1),set(vars.y_1,new_y1),set(vars.x_2,new_x2),set(vars.y_2,new_y2),fire_event(me,'create'),]"
			[/properties]


			[animation]
			image=characters/frogatto-tongueB.png
			rect=0,0,7,7
			frames=1
			no_remove_alpha_borders=true
			[/animation]
			
			on_create="[
				set(midpoint_x, (x_2+x_1)/2),
				set(y, (y_2+y_1)/2 - (length/2)),
				set(draw_area, [0, 0, img_w/2, length/2]),
				set(activation_area, [min(x_1,x_2) -200, min(y_1,y_2) -200, abs(x_1-x_2) +200, abs(y_1-y_2) +200]),  #xywh#
				set(rotate,(angle(x_1,y_1,x_2,y_2)-90) )
			]"

		[/object_type]

		[object_type]
		id=frogatto_head
		serializable=no
			[properties]
				is_player_body_part=1
			[/properties]
		
		on_spawned="switch(vars.angle, -90, animation('up'), -45, animation('updiag'), 0, animation('side'), 45, animation('downdiag'), 90, animation('down'))"
			[base:animation]
			image=characters/frogatto-spritesheet5.png
			pad=3
			frames=8
			duration=2
			no_remove_alpha_borders=true
			[/animation]
			
			[animation]
			id=up
			rect=2,1,35,26
			[/animation]

			[animation]
			id=updiag
			rect=2,30,35,55			
			[/animation]

			[animation]
			id=side
			rect=2,59,35,84
			[/animation]

			[animation]
			id=downdiag
			rect=2,88,35,113
			[/animation]

			[animation]
			id=down
			rect=2,117,35,142
			[/animation]


		[/object_type]

		[object_type]
		id=tongue_tip
		always_active=yes
		serializable=no
		zorder=6
		[consts]
		damage_cooldown=10
		[/consts]
		solid_dimensions=player,common,boss,thrown

		[tmp]
			frog=null
			froghead=null
			shaft=null
		[/tmp]
		[vars]
			timer=1
			tongue_angle=0
		[/vars]

		[properties]
			is_player_body_part=1
			attack_damage=0
			team="'player'"
			yhead_offset=12
			ybase_offset="8"
			x_offset="0*facing"
			tongue_duration=14  ##possible TODO: query this from tmp.frog
			length_per_time="def(time) tmp.frog.tongue_length*(tongue_duration/2 - abs(tongue_duration/2 - time))"
			set_shaft="def(time,angle) [	tmp.shaft.set_ends(	tmp.froghead.midpoint_x + x_offset,
																tmp.froghead.midpoint_y + ybase_offset,
																tmp.froghead.midpoint_x + (length_per_time(time)*cos(angle)) * facing + x_offset,
																tmp.froghead.midpoint_y + ybase_offset + (length_per_time(time)*sin(angle))  )]"
																
			adjust_position="def(time,angle)	[set(midpoint_x, tmp.froghead.midpoint_x + (length_per_time(time)*cos(angle)) * facing  + x_offset + if(facing = 1, 2,0)), 
												set(midpoint_y, tmp.froghead.midpoint_y + ybase_offset + (length_per_time(time)*sin(angle)) + if(facing = -1 and angle = 0, -1, 0) ),
												set(rotate, angle * facing)]"
		[/properties]
		
		on_spawned="[	spawn('frogatto_playable.tongue_shaft',x,y,1),
						spawn('frogatto_playable.frogatto_head',tmp.frog.midpoint_x,tmp.frog.midpoint_y-yhead_offset,facing, [set_var('angle',tongue_angle),set(parent,tmp.frog)])]"
		on_child_spawned="switch(child.type, 
								'frogatto_playable.tongue_shaft', set(tmp.shaft, child),
								'frogatto_playable.frogatto_head', set(tmp.froghead, child))"
		
		
		on_process="[add(vars.timer,1),set_shaft(vars.timer, tongue_angle),adjust_position(vars.timer,tongue_angle),if(vars.timer >= tongue_duration,die()),fire_event('drag_victim'),if(vars.timer = tongue_duration/2, animation('flash'))]"
		on_die="[if(vars.swallowed, [set(tmp.frog.vars.swallowed, vars.swallowed),add(tmp.frog.variations, ['fat'])]) ,set(tmp.shaft.hitpoints, 0), set(tmp.shaft, null()),set(tmp.froghead.hitpoints, 0), set(tmp.froghead, null()), set(tmp.frog.tmp.tongue_tip, null())]"

		## if we snag something early, fast-forward us to where the tongue is at the same position, but retracting.
		on_stopearly="[set(vars.timer, newtime), set(tmp.frog.time_in_animation,newtime)] where newtime = vars.timer + 2*abs(max((tongue_duration/2 - vars.timer),0))"
		on_drag_victim="[if(vars.swallowed and (level.cycle - vars.cycle_grabbed > 1), [set(vars.swallowed.midpoint_x, last_x),
		                                 set(vars.swallowed.midpoint_y, last_y)]),
		                set(last_x, midpoint_x), set(last_y, midpoint_y),
						]"
						   
						   
		on_collide_object_grab="[if((collide_with_area = 'body' or collide_with_area = 'thrown') and (not vars.swallowed) and collide_with != level.player,
	            [[fire_event('stopearly'), animation('flashsnag')],
					if(tag_ and (not tag_ in level.player.enemies_tasted),
							[
							add(level.player.enemies_tasted, [tag_]),
							#adding 1 since the list won't have been updated yet#
							if(size(level.player.enemies_tasted) + 1 >= 25, achievement('frogourmet'))
							]
							)
	            	where tag_ = collide_with.consts.frogourmet_tag,
				 if(is_swallowable,
	                        [remove_object(collide_with),
	  set(attached_objects, [collide_with]), set(vars.cycle_grabbed, level.cycle),
	  [set(collide_with.vars.removed_from_play, 1),sound('Gulp.wav')],
	  set(vars.swallowed, collide_with), fire_event(collide_with, 'swallowed')],
	  
	 #object is not swallowable, so do damage to it instead#
	 if(collide_with.get_hit_by, collide_with.get_hit_by(me))
	  )])] where is_swallowable = collide_with.tags.swallowable and collide_with.consts.size <= consts.max_swallow_size"
	  
	  on_create="animation('initial')"
	  
	  on_end_initial_anim="animation('normal')"
	  on_end_flash_anim="animation('normal')"
	  on_end_clung_anim="animation('clung')"
	  on_end_flashsnag_anim="animation('clung')"
	  		[vars]
			swallowed="null()"
	  		[/vars]
			[tmp]
			hit=0
			last_x=null()
			last_y=null()
			tongue_shaft=null()
			[/tmp]
			[consts]
			max_swallow_size=16
			[/consts]
			
			[animation]
			id=initial
			image=characters/frogatto-spritesheet1.png
			frames=1
			duration=4
			rect=307,351,339,383
			#grab_area=solid:all
			grab_area=solid:8,8,25,25
			[/animation]

			[animation]
			id=normal
			image=characters/frogatto-spritesheet1.png
			frames=1
			duration=100
			rect=379,351,411,383
			#grab_area=solid:all
			grab_area=solid:8,8,25,25
			[/animation]

			[animation]
			id=flashsnag
			image=characters/frogatto-spritesheet1.png
			frames=1
			duration=2
			rect=415,351,447,383
			[/animation]
			
			[animation]
			id=flash
			image=characters/frogatto-spritesheet1.png
			frames=1
			duration=2
			rect=343,351,375,383
			[/animation]

			[animation]
			id=clung
			image=characters/frogatto-spritesheet1.png
			frames=1
			duration=100
			rect=451,351,483,383
			[/animation]
		[/object_type]


#------------------------- HEAD FOR ENERGYSHOT -------------------------#
		[object_type]
		id=frogatto_head_energyshot
		serializable=no
		zorder=12
			[properties]
				is_player_body_part=1
			[/properties]
		
		on_spawned="[set(parent, spawner), schedule(9,die()),switch(vars.angle, -90, animation('up'), -45, animation('updiag'), 0, animation('side'), 45, animation('downdiag'), 90, animation('down'))]"
		
			[base:animation]
			image=characters/frogatto-spritesheet2.png
			pad=3
			frames=2
			frames_per_row=1
			duration=5
			no_remove_alpha_borders=true
			[/animation]
			
			[animation]
			id=up
			rect=178,415,218,458
			[/animation]

			[animation]
			id=updiag
			rect=222,415,262,458	
			[/animation]

			[animation]
			id=side
			rect=266,415,306,458
			[/animation]

			[animation]
			id=downdiag
			rect=310,415,350,458
			[/animation]

			[animation]
			id=down
			rect=354,415,394,458
			[/animation]


		[/object_type]



#------------------------- SHOTS -------------------------#
		[object_type]
		id=bubble_shot
		prototype=shot
		
			[vars]
				team="'player'"
			[/vars]
			
			[properties]
				team="'player'"
				dies_when_hit=0
				attack_damage=7.5
				damage_cooldown=10
			[/properties]
			
			on_spawned="set(vars.parent_obj, spawner)"
			
			on_end_normal_anim="animation('pop')"
			on_end_pop_anim="die()"
			on_enter_pop_anim="[set(velocity_x,0),set(velocity_y,0)]"

			[base:animation]
			image=effects/particles2.png
			pad=3
			[/animation]

			[animation]
			id=normal
			frames=3
			duration=8
			rect=62,2,71,11
			attack_area=all
			[/animation]

			[animation]
			id=pop
			frames=2
			duration=4
			rect=101,2,110,11
			#attack_area=all
			[/animation]
		
		[/object_type]
		
		[object_type]
		id=fire_shot
		prototype=shot
		zorder=50
		
	
			[properties]
				team="'player'"
				dies_when_hit=0
				attack_damage=25
				damage_cooldown=10
			[/properties]
			
			on_spawned="[set(vars.parent_obj, spawner),schedule(6,animation('pop'))]"
			
			on_end_normal_anim="animation('normal')"
			on_end_pop_anim="die()"
			on_enter_pop_anim="[set(velocity_x,0),set(velocity_y,-200-1d100),facing(if(1d2=2,1,-1)),set(zorder,40)]"

			[base:animation]
			image=effects/particles2.png
			pad=3
			[/animation]

			[animation]
			id=normal
			frames=4
			duration=2
			#rect=3,2,12,11
			rect=2,113,15,130
			attack_area=all
			[/animation]

			[animation]
			id=pop
			frames=3
			duration=2
			pad=3
			#rect=6,30,12,36
			rect=2,134,15,151
			#attack_area=all
			[/animation]
		
		[/object_type]

		[object_type]
		id=energyshot
		dies_on_inactive=true
	
		prototype=shot
	
		[properties]
			attack_damage=40
			team="'player'"
		[/properties]
		
		[vars]
			exploded=0
		[/vars]
	
		mass=2
		zorder=50
		on_create="[set(time_in_animation, 1d6),sound('energyshot.ogg'),
		schedule(50,die()),
		spawn('frogatto_playable.energyshot_bloom',midpoint_x,midpoint_y,0), add_particles('particles')]"

		on_process="[set(velocity_x,velocity_x*0.97),set(velocity_y,velocity_y*0.97)]"
		
		# When we die we want to keep the particles coming. So, we turn into a particle_system_holder object and set our hitpoints to the number of cycles we want to keep the particles running for. We schedule turning into the particle system holder next frame, because we want to remain as we are this frame so any remaining collisions can be properly resolved.
		on_die="[set(hitpoints, 30), if((not vars.exploded), [set(vars.exploded, 1), spawn('frogatto_playable.energyshot_bloom',midpoint_x,midpoint_y,0),sound('MechCrush.ogg'), set(hitpoints, 30), set(particles.spawn_rate, 0), schedule(0, [set(type, 'particle_system_holder'), fire_event('create')])])]"
		on_end_anim="[animation('normal')]"
	
			[animation]
			body_area=all
			attack_area=0,0,10,10
			id=normal
			image=effects/particles2.png
			x=3
			y=15
			w=10
			h=10
			pad=3
			frames=4
			duration=2
			[/animation]
			[particle_system]
			id=particles
			type=simple
			min_y=3
			max_y=5
			spawn_rate=1000
			time_to_live=20
			velocity_magnitude=1000
			velocity_magnitude_random=100
			velocity_rotate_random=360
				[animation]
				id=sparkle
				image=effects/particles2.png
				x=84
				y=19
				w=7
				h=7
				pad=3
				frames=4
				scale=2
				duration=5
				[/animation]
			[/particle_system]
		[/object_type]

	[object_type]
	id=energyshot_bloom
	dies_on_inactive=true
	ignore_collide=true

	#when our animation ends we want to disappear and transfer to being
	#a particle_system_holder which will keep the particle system going.
	on_end_anim="[set(hitpoints, 30), set(type, 'particle_system_holder'), fire_event('create')]"

	#we want to spawn a bunch of particles at the start, and then stop, so
	#we schedule an event to stop spawning immediately after we are created.
	on_create="[add_particles('particles'), schedule(1, fire_event('stop_spawning_particles'))]"
	on_stop_spawning_particles="set(particles.spawn_rate, 0)"
	zorder=10
		[animation]
		id=sparkle
		image=effects/powerup-fx.png
		x=122
		y=2
		w=21
		h=23
		pad=3
		frames=8
		frames_per_row=4
		duration=2
		zorder=10
		[/animation]
		[particle_system]
		id=particles
		type=simple
		spawn_rate=10000
		time_to_live=20
		min_x=10
		max_x=20
		min_y=10
		max_y=20
		velocity_magnitude=1000
		velocity_magnitude_random=1000
		velocity_rotate_random=360
			[animation]
			id=sparkle
			image=effects/particles2.png
			x=84
			y=19
			w=7
			h=7
			pad=3
			frames=4
			scale=2
			duration=5
			[/animation]
		[/particle_system]
	[/object_type]
		
	[/object_type]
