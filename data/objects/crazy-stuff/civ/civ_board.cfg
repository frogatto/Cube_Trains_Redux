#let ancestral know
[object_type]
	id=civ_board
	hitpoints=2
	zorder=-11
	no_compile_image="experimental/civ-tile.png"
	
	[editor_info]
		category=crazy-stuff
	[/editor_info]
	
	[consts]
		tiles = 14		# number of tiles on board #
		tile_size = 16	# size of tile image #
		hand_size = 6	# number of tiles in hand #
		land = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,3,0,1,1,0,0,0,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,0,1,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,1,1,1,1,2,2,2,1,1,0,0,0,0,0,1,1,1,2,3,2,2,1,1,1,0,0,0,0,0,1,2,2,2,2,2,0,0,0,0,0,0,1,1,1,1,2,2,3,2,2,0,0,0,0,0,0,1,1,0,0,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,]
		players = ['human', 'ai_die']
		tile_types = ['normal', 'gold', 'black', 'silver']
	[/consts]
	
	[vars]
		hand = []		#tiles in hand#
		play = []		#tiles in play#
		cache_version=0 #version of the cache that tiles have#
		turn = 0		#current side's turn#
	[/vars]
	
	[properties]		
		#returns the pixel size of the board#
		board_size = "def() consts.tile_size*consts.tiles"
		
		#returns the pixels of the board coordinate passed in.#
		tile_at = "def (coord) [x+consts.tile_size+x_in*consts.tile_size*2,y+consts.tile_size+y_in*consts.tile_size*2] where x_in = coord[0] where y_in = coord[1]"
		
		#returns the terrain type at coord#
		on_tile = "def(coords) 
			if(mx > x and mx < x+board_size()*2 and my > y and my < y+board_size()*2 and (not [tx, ty] in map(vars.play, 'vp', vp.vars.gridloc)),
				[tx, ty])
			where tx = (mx-x)/(consts.tile_size*2)
			where ty = (my-y)/(consts.tile_size*2)
			where mx = coords[0] where my = coords[1]"
		
		#Returns the tile the mouse is on.#
		mouse_on_tile = "def() on_tile(level.player.vars.mouse.pos)"
			
		
		#Takes player (0) and a spot in the hand to deal to.#
		dealt_hand_loc = "def(player, spot) if(spot in range(consts.hand_size) and player = 0,
		[x - consts.tile_size + margin + step * spot, y + board_size()*2 + space_beneath]
		where step = ((board_size() - margin) * 2) / (consts.hand_size - 1)
		where margin = 125
		where space_beneath = 20
		)"
		
		#Takes x,y board coordinate, returns terrain name there.#
		get_terrain = "def(coords) switch(consts.land[coords[0] + coords[1]*consts.tiles], 0, 'ocean_grid', 1, 'plains_grid', 2, 'hill_grid', 3, 'ore_grid', 'ocean_grid')"
		
		#Can coords tile have food for obj?#
		has_food = "def(obj, coords) 
			if(1 in map([[-1,0],[0,-1],[1,0],[0,1]], 'offset', 
				if(get_terrain([coords[0]+offset[0],coords[1]+offset[1]]) = 'plains_grid' and find(vars.play, 't', t.midpoint_x = tile_at([coords[0]+offset[0], coords[1]+offset[1]])[0] and t.midpoint_y = tile_at([coords[0]+offset[0], coords[1]+offset[1]])[1]) = null(),
					1, 
					0)
				), 
				1,
				0) 
			or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1])
			"
		
		#Is coords tile a valid spot to add obj?#
		is_valid_addition = "def(obj, coords) 
			switch(obj.type,
			'civ-tile_farm',	if(get_terrain(coords) = 'plains_grid', 1, 0),
			'civ-tile_mine',	if(get_terrain(coords) in ['hill_grid', 'ore_grid'] and has_food(obj, coords), 1, 0),
			'civ-tile_settle',	if(get_terrain(coords) != 'ocean_grid' and has_food(obj, coords), 1, 0),
			'civ-tile_war',		if(get_terrain(coords) != 'ocean_grid' and has_food(obj, coords), 1, 0),
			0)"
		
		#Returns the tile which was played at coords.#
		played = "def(coords) find(vars.play, 'tile', tile.gridloc)"
		
		#Darkens invalid positions for obj to be placed at.#
		draw_blackout = "def(tile) map(range(consts.tiles), 'cX', map(range(consts.tiles), 'cY', 
			if(not is_valid_addition(tile,[cX, cY]), 
				spawn('civ_board.no', tile_at([cX,cY])[0], tile_at([cX, cY])[1], facing))))"
		
		#Removes all blacked out tiles.#
		clear_blackout = "map(level.chars, 'obj', if(obj.type = 'civ_board.no', fire_event(obj, 'nix')))"
	[/properties]
	
	
	
	on_create="[set(draw_area, [0, 0, board_size(), board_size()]),
		
		[set(new_bag.vars.spawner, self),
		add_object(new_bag),
		set(vars.bag, new_bag),
		]where new_bag = object('civ-tile_bag', x + board_size()*2 + 100, y+((board_size()*5)/3), facing),
		
		if(size(consts.land) = consts.tiles*consts.tiles,
			map(range(size(consts.land)), 'land_index', spawn(self.type + '.' + ltype, lcoord[0], lcoord[1], facing) where lcoord = tile_at([land_index%consts.tiles, land_index/consts.tiles]) where ltype = switch(consts.land[land_index], 0, 'ocean_grid', 1, 'plain_grid', 2, 'hill_grid', 3, 'ore_grid', 'ocean_grid')),
			debug(size(consts.land), 'does not equal', consts.tiles*consts.tiles)),
			
		spawn('civ_logo', x + board_size()*2 + 100, y+((board_size()*2)/4), facing),
		
		
		
		]"
		
		
		
	on_lmb_down="map(vars.hand, 'tile', fire_event(tile, 'lmb_down', level.player.vars.mouse))"
		
	on_lmb_hold="[
		#debug('tile:', mouse_on_tile())#
		if(ot,
			[set(tmp.old_ot, ot),
			if(tmp.old_ot != ot,
				[set(tmp.tile_highlight, hlt),
				add_object(hlt),
				remove_object(tmp.tile_highlight),
				]where hlt = object('civ_board.tile', tile_at(ot)[0], tile_at(ot)[1], facing)
				)
			],
			[set(tmp.old_ot, 0),
			remove_object(tmp.tile_highlight),
			])
		where ot = mouse_on_tile()
		]"
		
	on_lmb_up="remove_object(tmp.tile_highlight)"
	
	
		
	on_release_tile="
	    if(mouse_on_tile(),
		[set(arg.midpoint_x, tile_at(mouse_on_tile())[0]),
		 set(arg.midpoint_y, tile_at(mouse_on_tile())[1]),
	     fire_event('release_tile_internal', arg)],
	     arg.go_to(dealt_hand_loc(0,arg.vars.hand_pos)))"

	on_release_tile_internal="
	    [#debug(tile_at(mouse_on_tile())),#
		if(mouse_on_tile() and is_valid_addition(arg, mouse_on_tile()), 
			[set(arg.midpoint_x, tile_at(mouse_on_tile())[0]), 
			set(arg.midpoint_y, tile_at(mouse_on_tile())[1]), 
			set(vars.play, vars.play + [arg]), #the crashy bit - Setting arg.midpoint_s before this function avoids a [] crash. Why?#
			fire_event('tiles_in_play_modified'),
			set(arg.vars.gridloc, mouse_on_tile()),
			set(vars.bag.vars.on_deal_tile, arg.vars.hand_pos),
			set(arg.animation, 'normal'),
			fire_event(vars.bag, 'deal_p1'),
			if(size(vars.bag.vars.pile) = 1, debug('Game Over'), fire_event('end_turn')),
			],
			arg.go_to(dealt_hand_loc(0,arg.vars.hand_pos)))
		]"
		
		
	
	on_tiles_in_play_modified="[add(vars.cache_version, 1),
	     map(vars.play, 'p', fire_event(p, 'calculate_surroundings')),
	     map(vars.play, 'p', fire_event(p, 'calculate_kingdom', context))]"
	     
	     
	
	on_rmb_down="debug(size(vars.bag.vars.piles[0]))"
	
	
	
	on_end_turn="schedule(20, [
		set(vars.turn, nt),
		switch(consts.players[nt],
		'human', [],
		'ai_die', [fire_event('ai_die_turn')],
		debug('Illegal side', nt),
		)
		] where nt = (vars.turn+1)%size(consts.players))"
	
	on_ai_die_turn="[
		[#debug(tile_to_place, '\n', tile_to_place[0].type),#
		set(tile_to_place[0].midpoint_x, tile_at(validity2d[eY][eX])[0]),
		set(tile_to_place[0].midpoint_y, tile_at(validity2d[eY][eX])[1]),
		set(tile_to_place[0].animation, consts.tile_types[vars.turn]),
		add_object(tile_to_place[0]),
		] where eX = 1d size(validity2d[eY])-1 #eX and eY are now valid locations coordinates.#
		where eY = 1d size(validity2d)-1
		where validity2d = filter(
			map(range(consts.tiles), 'cX', 
				filter(
					map(range(consts.tiles), 'cY', 
						if(is_valid_addition(tile,[cX, cY]), 
							[cX,cY]
							)
						), 
					'add', add != null)
				),
			'add', add != [])
		where tile = tile_to_place[0],
		
		tile_to_place[1],
		#debug('ended die`s turn'), fire_event('end_turn'),#
		] where tile_to_place = vars.bag.extract(vars.turn)"
	
	
	on_end_anim="animation('normal')"
	
	[animation]
		id=normal
		image=experimental/civ-tile.png
		x=0
		y=0
		w=16
		h=16
		pad=-1
		frames=1
		duration=6541
		surface_area=all
	[/animation]
	
	
	[object_type]
		id=tile
		hitpoints=2
		zorder=-8
		
		on_create = "[
			#set(red, tint), set(green, tint), set(blue, tint),#
			set(alpha, tint),
			] where tint = 75"
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=11
			y=10
			w=16
			h=16
			pad=-1
			frames=1
			duration=5541
			surface_area=all
		[/animation]
	[/object_type]
	
	
	[object_type]
		id=no
		hitpoints=2
		zorder=-9
		
		on_create = "[
			#set(red, tint), set(green, tint), set(blue, tint),#
			set(alpha, tint),
			] where tint = 75"
			
		on_nix="die()"
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=30
			y=10
			w=16
			h=16
			pad=-1
			frames=1
			duration=6541
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=ocean_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=14
			y=85
			w=16
			h=16
			pad=-1
			frames=1
			duration=542
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=plain_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=14
			y=108
			w=16
			h=16
			pad=-1
			frames=1
			duration=543
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=hill_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=14
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=544
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=ore_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=33
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=999999999
			surface_area=all
		[/animation]
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=52
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=999999999
			surface_area=all
		[/animation]
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=71
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=999999999
			surface_area=all
		[/animation]
	[/object_type]
	
[/object_type]
