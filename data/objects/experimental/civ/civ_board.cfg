#let ancestral know (done)
#let bentleymt know (next stable) 1

[object_type]
	id=civ_board
	hitpoints=2
	zorder=-11
	no_compile_image="experimental/civ-tile.png"
	
	[editor_info]
		category=crazy-stuff
	[/editor_info]
	
	[consts]
		tiles = 14		# number of tiles on board #
		tile_size = 16	# size of tile image #
		land = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,3,0,1,1,0,0,0,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,0,1,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,1,1,1,1,2,2,2,1,1,0,0,0,0,0,1,1,1,2,3,2,2,1,1,1,0,0,0,0,0,1,2,2,2,2,2,0,0,0,0,0,0,1,1,1,1,2,2,3,2,2,0,0,0,0,0,0,1,1,0,0,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,] #land: See is_valid_addition for types.#
		players = ['human'] #types are: 'human', 'ai_die'
		tile_types = ['normal', 'gold', 'black', 'silver']
	[/consts]
	
	[vars]
		hand = []					# tiles in hand
		play = []					# tiles in play
		cache_version=0				# version of the cache that tiles have
		turn = 0					# current side's turn
		hand_size = 6				# number of tiles in hand 
		camera_pos = [0,0,0,0]		# initial location of the camera in the level
		help_text_pos = [50, 575]	# the location of the help text controller
		recruited = []				# warriors which have been selected to go to battel, but have not done so yet?
		not_refilled_when_played=[] # list of tiles in hand which can be refilled?
		bldg_spots = [[],[],[],[]]	# a list of tile quads available for bulding superstructures on
		bldg_codes = "{				# for each finishing tile, what are the legal combos to build a building? A tile type maps to a list of lists which contain a list of the four needed tiles. These tiles are matched in order, with 'wild' as a wildcard. This list is followed by the event to execute when the list is successfully matched.#
			'civ-tile_settle' -> [
				[['civ-tile_settle', 'civ-tile_settle', 'civ-tile_war', 'civ-tile_war'], 'new_fortified_city'],
				[['civ-tile_settle', 'civ-tile_settle', 'wild', 'wild'], 'new_city'],
				],
			'civ-tile_war' -> [
				[['civ-tile_war', 'civ-tile_war', 'civ-tile_war', 'civ-tile_war'], 'new_base'],
				],
			}"
	[/vars]
	
	[properties]
		tile_side_name = "def(name) switch(name.animation, 'normal', ~White~, 'gold', ~Gold~, 'black', ~Black~, 'silver', ~Silver~, ~Mysterious Stranger~)"
		tile_name = "def(tile) switch(tile.type, 'civ-tile_mine', ~mine~, 'civ-tile_farm', ~farm~, 'civ-tile_settle', ~settlement~, 'civ-tile_war', ~warrior camp~, ~claim~)"
		
		#returns the pixel size of the board#
		board_size = "def() consts.tile_size*consts.tiles"
		
		#returns the pixels of the board coordinate passed in.#
		tile_at = "def (coord) [x+consts.tile_size+x_in*consts.tile_size*2,y+consts.tile_size+y_in*consts.tile_size*2] where x_in = coord[0] where y_in = coord[1]"
		
		#returns the tile number at level coord if available#
		on_tile = "def(coords) 
			if(not loc in map(vars.play, 'vp', vp.vars.gridloc), loc) where loc = on_any_tile(coords)"
			
		#returns tile number at level coord
		on_any_tile = "def(coords) 
			if(mx > x and mx < x+board_size()*2 and my > y and my < y+board_size()*2,
				[tx, ty])
			where tx = (mx-x)/(consts.tile_size*2)
			where ty = (my-y)/(consts.tile_size*2)
			where mx = coords[0] where my = coords[1]"
			
		#returns the played tile at the level coord
		on_piece = "def(coords) find(vars.play, 'vp', vp.vars.gridloc = on_any_tile(coords))"
		
		#Returns the tile the mouse is on.#
		mouse_on_tile = "def() on_any_tile(level.player.vars.mouse.pos)"
			
		
		#Takes player (0) and a spot in the hand to deal to.#
		dealt_hand_loc = "def(player, spot) if(spot in range(vars.hand_size) and player = 0,
		[x - consts.tile_size + margin + step * spot, y + board_size()*2 + space_beneath]
		where step = ((board_size() - margin) * 2) / (vars.hand_size - 1)
		where margin = 125
		where space_beneath = 20
		)"
		
		#Takes x,y board coordinate, returns terrain name there.#
		get_terrain = "def(coords) switch(consts.land[coords[0] + coords[1]*consts.tiles], 0, 'ocean_grid', 1, 'plains_grid', 2, 'hill_grid', 3, 'ore_grid', 'ocean_grid')"
		
		#Can coords tile have food for obj?#
		has_food = "def(obj, coords) 
			has_food_with(obj, coords, [-1,-1])
			"
		
		#list of vectors for adjacent tiles#
		adjacents = "[[-1,0],[0,-1],[1,0],[0,1]]"
		
		#returns objects in play adjacent to coords#
		adjacent_objs = "def(coords) filter(map(adjacents, 'adjv', find(vars.play, 'tile', tile.vars.gridloc = [coords[0]+adjv[0], coords[1]+adjv[1]])), 'list', list != null)"
		
		#same as has_food, but without taking to account tile at less.#
		has_food_with = "def(obj, coords, less) 
			if(1 in map(adjacents, 'offset', 
				if(get_terrain([coords[0]+offset[0],coords[1]+offset[1]]) = 'plains_grid'
				and find(vars.play, 't', t.midpoint_x = tile_at([coords[0]+offset[0], coords[1]+offset[1]])[0] 
				and t.midpoint_y = tile_at([coords[0]+offset[0], coords[1]+offset[1]])[1]) = null(),
					if([coords[0]+offset[0],coords[1]+offset[1]] = less, 0, 1), 
					0)
				), 
				1,
				0)
			or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)
		#	or 'civ-tile_farm' in map(k_group(tile_at(coords), obj.animation), 'k_tile', k_tile.type)
		#"	#Well, bother. This bit doesn't work here - a corner case(specifically, the lower right one) is broken.
		
		#returns a list of the tiles which will starve if coord is filled with obj. needs work. adjs is the tiles adjacent to coords.#
		starve = "def(obj, coords) filter(adjacent_objs(coords), 'adjs', not has_food_with(obj, adjs.vars.gridloc, coords))"
		
		#Is coords tile a valid spot to add obj?#
		is_valid_addition = "def(obj, coords) 
			switch(obj.type,
			'civ-tile_farm',	if(get_terrain(coords) = 'plains_grid' and (not played(coords)),
									1, 0),
			'civ-tile_mine',	if(get_terrain(coords) in ['hill_grid', 'ore_grid'] 
								and has_food(obj, coords) and (not played(coords))
								and ((not find(starve(obj, coords), 'dead', dead.animation = obj.animation))
									or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)), 
									1, 0),
			'civ-tile_settle',	if(get_terrain(coords) != 'ocean_grid' 
								and has_food(obj, coords) 
								and (not played(coords)) 
								and ((not find(starve(obj, coords), 'dead', dead.animation = obj.animation)) 
									or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)), 
									1, 0),
			'civ-tile_war',		if(get_terrain(coords) != 'ocean_grid' and has_food(obj, coords) 
								and (not find(vars.play, 'tile', tile.gridloc = coords 
								and tile.animation = obj.animation)) 
								and ((not find(starve(obj, coords), 'dead', dead.animation = obj.animation)) 
									or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)), 
									1, 0),
			0)"
		
		#Returns the tile which was played at coords.#
		played = "def(coords) find(vars.play, 'tile', tile.gridloc = coords)"
		
		#Darkens invalid positions for obj to be placed at.#
		draw_blackout = "def(tile) map(range(consts.tiles), 'cX', map(range(consts.tiles), 'cY', 
			if(not is_valid_addition(tile,[cX, cY]) and 'human' = consts.players[vars.turn], 
				spawn('civ_board.no', tile_at([cX,cY])[0], tile_at([cX, cY])[1], facing))))"
		
		#Removes all blacked out tiles.#
		clear_blackout = "map(level.chars, 'obj', if(obj.type = 'civ_board.no', fire_event(obj, 'nix')))"
		
		mouse = "level.player.vars.mouse.pos"
		
		flatten = "def(items) if(items.size = 0, [], items[0] + flatten(items[1:size(items)]))"
		
		war_defeat_tile = "def(tile) [
			set(vars.play, filter(vars.play, 'vp', vp != tile)),
			fire_event(tile, 'nix'),
			fire_event('tiles_in_play_modified'),
			[add_object(war_obj), 
			set(war_obj.midpoint_x, tile.midpoint_x), 
			set(war_obj.midpoint_y, tile.midpoint_y)
			] where war_obj = object('civ_war', x, y, facing), 
			]"
		
		#Takes a coordinate value which is being attacked, and returns the number of war tile objects to be played. See ai_die_turn comment for more details.#
		ai_die_war = "def(coord) (1d2)-1"
		
		#Uncached kingdom group functions. k_group returns the /side/ kingdom near /coords/.#
		k_group="def(coords, side) filter(_k_touching(coords, side, []), 'obj', obj != null())"
		_k_touching="def(coords, side, black)
			if(not size(filter(adjs, 'adj', adj = null())) = size(adjs), 
				map(filter(adjs, 'adj', adj != null()), 'adj', _k_touching([adj.midpoint_x, adj.midpoint_y], side, black + adjs))[0], 
				[_k_valid(on_piece(coords), side, black)] + black
				) where adjs = map(_k_adjacent(coords), 'obj', _k_valid(obj, side, black))"
		_k_valid="def(obj, side, black) if(obj.animation=side and (not obj in black), obj, null())"
		_k_adjacent="def(coords) map(adjacents, 'adj', on_piece([adj[0]*consts.tile_size*2 + coords[0], adj[1]*consts.tile_size*2 + coords[1]]))"
		
		#set the help text to string#
		help="def(string) vars.help_obj.set_text(string)"
		
		#Add a tile at board coordinates to the game data. Doesn't create tile.#
		add_tile="def(tile, coords) [
			set(tile.vars.gridloc, coords),
			set(tile.midpoint_x, tile_at(coords)[0]), 
			set(tile.midpoint_y, tile_at(coords)[1]), 
			set(vars.play, vars.play + [tile]),
			fire_event('tiles_in_play_modified')]"
		
		#the list of current player's potential buildings
		my_bldg_spots = "bldg_spots[turn]"
		
		#returns the quad (a list of four buildings) which could support the current tile as an addition.
		my_valid_bldg = "def(tile, list_of_quads) 
			my_valid_bldg_at([tile.midpoint_x, tile.midpoint_y], tile, list_of_quads)"
		my_valid_bldg_at = "def(coords, tile, list_of_quads) 
			find(list_of_quads, 'quad', 
				quad[0].gridloc = on_any_tile([coords[0]-consts.tile_size, coords[1]-consts.tile_size])
				and bldg_codes[tile.type]
				and (1=1) in map(range(size(bldg_codes[tile.type])), 'index', 
					pair_off(
						map(quad, 'l2', l2.type), 
						map(bldg_codes[tile.type][index][0], 'l1', l1.type)
						)
					)
				)"
		
		#matches pairs elements in the two lists passed in and returns true if it can pair off all elements in at least one list.. It accepts the string 'wild' as a wildcard, but will not attempt to optimise this card's use in any way. To make the wildcard the last resort, put it at the end of the list. Wild cards only accepted in second list.#
		pair_off = "def(list1, list2) #current bug: pair_off([1,1,'wild','wild'], [5,4,5,1]) matches and shouldn't. Vica-versa is fine.#
			if(size(list1)=0 and size(list2)=0,
				(1=1), 
				if((not (size(list1)=0 or size(list2)=0)) and pair,
					#I think the below filter is off.#
					pair_off(list1[1:size(list1)#add +1 here to break#], list2[0:index_to_nix] + list2[index_to_nix+1:size(list2)] where index_to_nix = find(map(range(size(list2)), 'index', if(list2[index] = list1[0] or list2[index] = 'wild' or list1[0] = 'wild', index, -1)), 'num', num >= 0)),
					(0=1)
					) where pair = list1[0] in list2 or 'wild' in (list2 + list1)
				)"
		
		
	[/properties]
	
	
	
	on_create="['We set up a lot of stuff in on_create so we don`t have to set it up again later.',
		#debug(pair_off([5,4,1,1], [1,1,'wild','wild'])),#
		set(draw_area, [0, 0, board_size(), board_size()]),
		set(vars.camera_pos, level.camera_position),
		[set(new_bag.vars.spawner, self),
		add_object(new_bag),
		set(vars.bag, new_bag),
		]where new_bag = object('civ-tile_bag', x + board_size()*2 + right_column_offset, y+((board_size()*5)/3), facing),
		
		if(size(consts.land) = consts.tiles*consts.tiles,
			map(range(size(consts.land)), 'land_index', spawn(self.type + '.' + ltype, lcoord[0], lcoord[1], facing) where lcoord = tile_at([land_index%consts.tiles, land_index/consts.tiles]) where ltype = switch(consts.land[land_index], 0, 'ocean_grid', 1, 'plain_grid', 2, 'hill_grid', 3, 'ore_grid', 'ocean_grid')),
			debug(size(consts.land), ' does not equal ', consts.tiles*consts.tiles, ', failed creating map tiles from land data.')),
			
		spawn('civ_logo', x + board_size()*2 + right_column_offset, y+((board_size()*2)/4), facing),
		
		if(consts.players[0] != 'human' ,[set(vars.turn, -1), fire_event('end_turn')]),
		
		schedule(3, fire_event('find_buttons')),
		
		[set(vars.help_obj, help_obj),
		help_obj.set_text(~Drag a tile to the board to play. Right-click for help.~),
		add_object(help_obj),
		] where help_obj = object('text_controller',help_text_pos[0],help_text_pos[1],0)
		
		] where right_column_offset = 125
		where camera = get_object(level, 'logic')"
		
	on_find_buttons="[set(vars.turn_button, bag.turn_button), set(vars.fight_button, get_object(level, 'fight')), set(get_object(level, 'fight').board, self)]"
	
	on_replace = "[
		#set(vars.mode, 'replace'),#
		map(range(size(not_refilled_when_played)), 'ind', schedule(ind*4, [
			set(vars.bag.vars.on_deal_tile, not_refilled_when_played[ind].vars.hand_pos),
			fire_event(vars.bag, 'deal_p1'),])),
		schedule(29, fire_event('end_turn')),
		]"
		
	on_refresh_warrior_selected_text="get_object(level, 'strength').set_text(~Armies:~ + '\n' + str(strengths[0]) + ~(+?) VS ~ + str(strengths[1]) + ~(+~ + str(size(recruited)) + ~)~)"
	
	on_rmb_down="[
		map(vars.hand, 'tile', if(help_txt, help(help_txt)) where help_txt = tile.help(level.player.vars.mouse)),
		]"
		
	on_lmb_down="[
		fire_event(vars.turn_button, 'lmb_hold', level.player.vars.mouse),
		fire_event(vars.fight_button, 'lmb_hold', level.player.vars.mouse),
		if(not war, [
		map(vars.hand, 'tile', fire_event(tile, 'lmb_down', level.player.vars.mouse)),
		],
		map(vars.hand, 'tile', fire_event(tile, 'war_select', level.player.vars.mouse)),
		)]"
		
	on_lmb_hold="if(not war, [
		#debug('tile:', mouse_on_tile())#
		if(ot,
			[set(tmp.old_ot, ot),
			if(tmp.old_ot != ot,
				[set(tmp.tile_highlight, hlt),
				add_object(hlt),
				remove_object(tmp.tile_highlight),
				]where hlt = object('civ_board.tile', tile_at(ot)[0], tile_at(ot)[1], facing)
				)
			],
			[set(tmp.old_ot, 0),
			remove_object(tmp.tile_highlight),
			])
		where ot = mouse_on_tile(),
		
		fire_event(vars.turn_button, 'lmb_hold', level.player.vars.mouse),
		fire_event(vars.fight_button, 'lmb_hold', level.player.vars.mouse),
		])"
		
	on_lmb_up="[
		remove_object(tmp.tile_highlight),
		fire_event(vars.turn_button, 'lmb_up', level.player.vars.mouse),
		fire_event(vars.fight_button, 'lmb_up', level.player.vars.mouse),
		]"
	
	
		
	on_release_tile="
	    if(mouse_on_tile() and consts.players[vars.turn] = 'human',
		[set(arg.midpoint_x, tile_at(mouse_on_tile())[0]),
		 set(arg.midpoint_y, tile_at(mouse_on_tile())[1]),
		 debug(my_valid_bldg(arg, my_bldg_spots)),
	     fire_event('release_tile_internal', arg)],
	     fire_event('fail_release_tile', arg))"

	on_release_tile_internal="if(not vars.war,
	    [#debug(tile_at(mouse_on_tile())),#
		if(mot and is_valid_addition(arg, mouse_on_tile()) and (not arg.type = 'civ-tile_war' and (played(mouse_on_tile()))), #add a tile normally#
			[set(arg.vars.gridloc, mot),
			set(arg.midpoint_x, tile_at(mot)[0]), 
			set(arg.midpoint_y, tile_at(mot)[1]), 
			set(vars.play, vars.play + [arg]), #the crashy bit - Setting arg.midpoint_s before this function avoids a [] crash. Why?#
			fire_event('tiles_in_play_modified'),
			set(vars.bag.vars.on_deal_tile, arg.vars.hand_pos),
			set(arg.animation, consts.tile_types[vars.turn]),
			fire_event(vars.bag, 'deal_p1'),
			if(size(vars.bag.vars.piles[vars.turn]) = 1, debug('Game Over'), fire_event('end_turn')),
			],
			fire_event('fail_release_tile', arg))
			where mot = mouse_on_tile(),
		])"
		
	on_fail_release_tile="
		if((not on_piece(mouse).animation != arg.animation) or arg.type != 'civ-tile_war' or (not on_any_tile(mouse)), 
			fire_event('rehand_tile', arg),
			if(is_valid_addition(arg, mouse_on_tile()), #WAR!#
				[#set(arg.midpoint_x, mouse[0]),
				set(arg.midpoint_y, mouse[1]),#
				
				fire_event('war', arg),
				#war_defeat_tile(on_piece(mouse)),#
				fire_event('release_tile_internal', arg),
				
				], 
				fire_event('rehand_tile', arg),)
			)"
			
	on_recalculate_end_turn_button_state="[
		#debug(vars.not_refilled_when_played),#
		if(size(vars.not_refilled_when_played) > 0, bag.turn_button.set_state('replace')),
		]"
		
	on_war="[ #set up the war#
		set(vars.war, 1),
		set(vars.help_obj.x, vars.help_obj.x - 220),
		help('Select additional warrior tiles from hand for one-time use.'),
		set(level.lock_screen, [vars.camera_pos[0]+vars.camera_pos[2]/2-220,vars.camera_pos[1]+vars.camera_pos[3]/2]),
		set(arg.zorder, arg.zorder + 1), #doesn't work#
		fire_event('make_blink', on_piece(mouse)),
		schedule(20, fire_event('make_blink', arg)),
		get_object(level, 'vs').set_text(tile_side_name(on_piece(mouse)) + ~ VS ~ + tile_side_name(arg.animation)),
		get_object(level, 'strength').set_text(~Armies:~ + '\n' + str(strengths[0]) + ~(+?) VS ~ + str(strengths[1]) + ~(+0)~),
		set(vars.strengths, strengths),
		set(vars.war_arg, arg), set(vars.war_on, on_piece(mouse)),
		#war_defeat_tile(on_piece(mouse)),#
		] where strengths = [size(filter(k_group(mouse, on_piece(mouse).animation), 'tile', tile.type = 'civ-tile_war')), size(filter(k_group(mouse, arg.animation), 'tile', tile.type = 'civ-tile_war'))+1]"
	
	on_fight="
		map(range(size(actions)), 'index', schedule(index * 10, actions[index]))
		where actions = if(size(recruited) > 0, map(range(size(recruited)), 'rind', [
			map(range(res), 'delay', schedule(delay, [
				set(recruited[rind].x, (recruited[rind].x*(res-delay) + war_arg.x*delay)/res),
				set(recruited[rind].y, (recruited[rind].y*(res-delay) + war_arg.y*delay)/res)])) where res = 20,
			schedule(21, fire_event(recruited[rind], 'nix'))
			]))
		+ [schedule(if(size(recruited) > 0, 15, 0), [ #finish the fight#
		set(vars.war, 0),
		set(vars.help_obj.x, vars.help_obj.x + 220),
		set(level.lock_screen, [vars.camera_pos[0]+vars.camera_pos[2]/2,vars.camera_pos[1]+vars.camera_pos[3]/2]),
		set(vars.war_arg.zorder, arg.zorder - 1),
		if(strengths[0]+ai_die_war(vars.war_on.vars.gridloc) >= strengths[1]+size(recruited), 
			[war_defeat_tile(vars.war_arg),
			help(tile_side_name(vars.war_arg) + ~'s warriors have fled! (~ + str(strengths[0]+ai_die_war(vars.war_on.vars.gridloc)) + ~ to ~ + str(strengths[1]+size(recruited)) + ~)~),
			],
			[war_defeat_tile(vars.war_on), 
			add_tile(vars.war_arg, on_any_tile([vars.war_arg.midpoint_x,vars.war_arg.midpoint_y])),
			help(~A ~ + tile_side_name(vars.war_on) + ' ' + tile_name(vars.war_on) + ~ was destroyed by ~ + tile_side_name(vars.war_arg) + ~'s warriors! (~ + str(strengths[0]+ai_die_war(vars.war_on.vars.gridloc)) + ~ to ~ + str(strengths[1]+size(recruited)) + ~)~),
			]),
			set(vars.bag.vars.on_deal_tile, vars.war_arg.vars.hand_pos),
			fire_event(vars.bag, 'deal_p1'),
			set(recruited, []),
			set(not_refilled_when_played, recruited),
			#debug(recruited),#
			if(size(vars.bag.vars.piles[vars.turn]) = 1, debug('Game Over'), fire_event('end_turn')),
			schedule(15, fire_event('recalculate_end_turn_button_state')),
		])]"
	
	on_make_blink="[set(arg.alpha, 0), schedule(20, [set(arg.alpha, 256), schedule(20, if(vars.war, fire_event('make_blink', arg)))])]"
		
	on_rehand_tile="arg.go_to(dealt_hand_loc(0,arg.vars.hand_pos))"
	
	
	
	on_tiles_in_play_modified="[add(vars.cache_version, 1),
		map(vars.play, 'p', [
			fire_event(p, 'calculate_surroundings'), 
			fire_event(p, 'calculate_kingdom', context)
			]),
		set(vars.bldg_spots,  map(consts.tile_types, 'ttype', #for each side, a list of quads of tiles available for building on#
			#'\n' + size(sideTiles) + 'x side ' + ttype#
			filter(map(sideTiles, 'sideTile', 
				if(not null in tileQuad, tileQuad)
				where tileQuad = [
					sideTile,
					find(sideTiles, 'st', st.gridloc = list_add(sideTile.gridloc,[1,0])),
					find(sideTiles, 'st', st.gridloc = list_add(sideTile.gridloc,[0,1])),
					find(sideTiles, 'st', st.gridloc = list_add(sideTile.gridloc,[1,1]))
					]
				), 'quads', quads != null)
			where sideTiles = filter(vars.play, 'inPlay', inPlay.animation = ttype and inPlay.bldg_status = 0)
			)),
		#debug(bldg_spots),#
		]"
	
	
	
	on_end_turn="[[schedule(25, [
		switch(consts.players[nt],
		'human', [],
		'ai_die', [fire_event('ai_die_turn')],
		debug('Illegal side', nt),
		),
		#debug(str(tile.animation) + ' ' + str(tile.type) + ' at ' + str(tile.vars.gridloc)) where tile = vars.play[size(vars.play)-1],#
		]),
		set(vars.turn, nt),
		] where nt = (vars.turn+1)%size(consts.players),
		map(vars.play, 'tile', 
			if(not (has_food(tile, tile.vars.gridloc) or tile.type = 'civ-tile_farm'), [
				set(vars.play, filter(vars.play, 'in_play', in_play != tile)), 
				fire_event(tile, 'nix'), 
				[add_object(starve_obj), 
				set(starve_obj.midpoint_x, tile.midpoint_x), 
				set(starve_obj.midpoint_y, tile.midpoint_y)
				] where starve_obj = object('civ_starve', x, y, facing), 
				fire_event('tiles_in_play_modified')
				])
			),
		]"
		
		
	#The code for the die AI. This sequence performs the actions every AI should do. Each
		#AI must fire_event('end_turn') when it is done. (This is the 'next turn' button.)
		#Tiles need to be placed manually (by setting an x, y), and each tile played needs
		#to be added to vars.play. Then, fire_event('tiles_in_play_modified') to update the
		#kingdom cache. A note, vars.bag.extract(vars.turn) returns a list containing the tile
		#object (index 0), which we see, but it also returns a series of instructions (index 1)
		#to remove the object from the tile bag. Make sure to run these instructions, or the
		#bag will never empty.#
	on_ai_die_turn="[
		if(size(validity2d) > 0, [
			set(tile_to_place[0].midpoint_x, tile_at(validity2d[eY][eX])[0]), #set tile pos to grid we chose#
			set(tile_to_place[0].midpoint_y, tile_at(validity2d[eY][eX])[1]),
			set(tile_to_place[0].animation, consts.tile_types[vars.turn]), #set the animation to the current side#
			fire_event('tiles_in_play_modified'),	#update the tile cache#
			set(tile_to_place[0].vars.gridloc, validity2d[eY][eX]), #set the grid location of the tile#
			set(vars.play, vars.play+[tile_to_place[0]]), #add the tile to the list of tiles in play#
			add_object(tile_to_place[0]),
			tile_to_place[1], #actually remove the object from it's bag#
			] where eX = (1d (size(validity2d[eY])))-1 #eX and eY are now valid locations coordinates.#
			where eY = (1d (size(validity2d)))-1,
			fire_event('ai_die_turn'),
			)
		where validity2d = filter(
			map(range(consts.tiles), 'cX', 
				filter(
					map(range(consts.tiles), 'cY', 
						if(is_valid_addition(tile,[cX, cY])
						and (not [cX, cY] in map(vars.play, 'tile', tile.vars.gridloc)
						and ((not find(starve(tile, [cX, cY]), 'dead', dead.animation = tile.animation))
						  or tile.search_adjacent_connected_to_farm(tile_at([cX, cY])[0], tile_at([cX, cY])[1], consts.tile_types[vars.turn])))
						and has_food(tile, [cX, cY]), 
							[cX,cY]
							)
						), 
					'add', add != null)
				),
			'add', add != [])
		where tile = tile_to_place[0],
		
		#debug('ended die`s turn'),# fire_event('end_turn'),
		] where tile_to_place = vars.bag.extract(vars.turn)"
	
	
	on_end_anim="animation('normal')"
	
	[animation]
		id=normal
		image=experimental/civ-tile.png
		x=0
		y=0
		w=16
		h=16
		pad=-1
		frames=1
		duration=6541
		surface_area=all
	[/animation]
	
	
	[object_type]
		id=tile
		hitpoints=2
		zorder=-8
		
		on_create = "[
			#set(red, tint), set(green, tint), set(blue, tint),#
			set(alpha, tint),
			] where tint = 75"
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=11
			y=10
			w=16
			h=16
			pad=-1
			frames=1
			duration=5541
			surface_area=all
		[/animation]
	[/object_type]
	
	
	[object_type]
		id=no
		hitpoints=2
		zorder=9
		
		on_create = "[
			#set(red, tint), set(green, tint), set(blue, tint),#
			set(alpha, tint),
			] where tint = 75"
			
		on_nix="die()"
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=30
			y=10
			w=16
			h=16
			pad=-1
			frames=1
			duration=6541
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=ocean_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=14
			y=85
			w=16
			h=16
			pad=-1
			frames=1
			duration=542
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=plain_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=14
			y=108
			w=16
			h=16
			pad=-1
			frames=1
			duration=543
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=hill_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=14
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=544
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=ore_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=33
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=999999999
			surface_area=all
		[/animation]
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=52
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=999999999
			surface_area=all
		[/animation]
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=71
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=999999999
			surface_area=all
		[/animation]
	[/object_type]
	
[/object_type]
