#let ancestral know (done)
#let bentleymt know (next stable) 1

#crashes after 5 turns when human != normal
[object_type]
	id=civ_board
	hitpoints=2
	zorder=-11
	no_compile_image="experimental/civ-tile.png"
	
	[editor_info]
		category=crazy-stuff
	[/editor_info]
	
	[consts]
		tiles = 14		# number of tiles on board #
		tile_size = 16	# size of tile image #
		land = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,3,0,1,1,0,0,0,0,0,0,0,0,0,2,2,1,1,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,2,2,0,0,0,0,0,1,1,0,0,0,0,0,0,2,0,0,0,0,0,0,1,1,2,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,1,1,0,0,0,0,0,0,1,1,1,1,2,2,2,1,1,0,0,0,0,0,1,1,1,2,3,2,2,1,1,1,0,0,0,0,0,1,2,2,2,2,2,0,0,0,0,0,0,1,1,1,1,2,2,3,2,2,0,0,0,0,0,0,1,1,0,0,2,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,] #land: See is_valid_addition for types.#
		players = ['human', 'ai_die', 'ai_die', ] #types are: 'human', 'ai_die'
		tile_types = ['normal', 'gold', 'black', 'silver']
	[/consts]
	
	[vars]
		hand = []		#tiles in hand#
		play = []		#tiles in play#
		cache_version=0 #version of the cache that tiles have#
		turn = 0		#current side's turn#
		hand_size = 6	# number of tiles in hand #
	[/vars]
	
	[properties]		
		#returns the pixel size of the board#
		board_size = "def() consts.tile_size*consts.tiles"
		
		#returns the pixels of the board coordinate passed in.#
		tile_at = "def (coord) [x+consts.tile_size+x_in*consts.tile_size*2,y+consts.tile_size+y_in*consts.tile_size*2] where x_in = coord[0] where y_in = coord[1]"
		
		#returns the tile number at level coord if available#
		on_tile = "def(coords) 
			if(not loc in map(vars.play, 'vp', vp.vars.gridloc), loc) where loc = on_any_tile(coords)"
			
		#returns tile number at level coord
		on_any_tile = "def(coords) 
			if(mx > x and mx < x+board_size()*2 and my > y and my < y+board_size()*2,
				[tx, ty])
			where tx = (mx-x)/(consts.tile_size*2)
			where ty = (my-y)/(consts.tile_size*2)
			where mx = coords[0] where my = coords[1]"
			
		#returns the played tile at the level coord
		on_piece = "def(coords) find(vars.play, 'vp', vp.vars.gridloc = on_any_tile(coords))"
		
		#Returns the tile the mouse is on.#
		mouse_on_tile = "def() on_any_tile(level.player.vars.mouse.pos)"
			
		
		#Takes player (0) and a spot in the hand to deal to.#
		dealt_hand_loc = "def(player, spot) if(spot in range(vars.hand_size) and player = 0,
		[x - consts.tile_size + margin + step * spot, y + board_size()*2 + space_beneath]
		where step = ((board_size() - margin) * 2) / (vars.hand_size - 1)
		where margin = 125
		where space_beneath = 20
		)"
		
		#Takes x,y board coordinate, returns terrain name there.#
		get_terrain = "def(coords) switch(consts.land[coords[0] + coords[1]*consts.tiles], 0, 'ocean_grid', 1, 'plains_grid', 2, 'hill_grid', 3, 'ore_grid', 'ocean_grid')"
		
		#Can coords tile have food for obj?#
		has_food = "def(obj, coords) 
			has_food_with(obj, coords, [-1,-1])
			"
		
		#list of vectors for adjacent tiles#
		adjacents = "[[-1,0],[0,-1],[1,0],[0,1]]"
		
		#returns objects in play adjacent to coords#
		adjacent_objs = "def(coords) filter(map(adjacents, 'adjv', find(vars.play, 'tile', tile.vars.gridloc = [coords[0]+adjv[0], coords[1]+adjv[1]])), 'list', list != null)"
		
		#same as has_food, but without taking to account tile at less.#
		has_food_with = "def(obj, coords, less) 
			if(1 in map(adjacents, 'offset', 
				if(get_terrain([coords[0]+offset[0],coords[1]+offset[1]]) = 'plains_grid'
				and find(vars.play, 't', t.midpoint_x = tile_at([coords[0]+offset[0], coords[1]+offset[1]])[0] 
				and t.midpoint_y = tile_at([coords[0]+offset[0], coords[1]+offset[1]])[1]) = null(),
					if([coords[0]+offset[0],coords[1]+offset[1]] = less, 0, 1), 
					0)
				), 
				1,
				0) 
			or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)"
		
		#returns a list of the tiles which will starve if coord is filled with obj. needs work. adjs is the tiles adjacent to coords.#
		starve = "def(obj, coords) filter(adjacent_objs(coords), 'adjs', not has_food_with(obj, adjs.vars.gridloc, coords))"
		
		#Is coords tile a valid spot to add obj?#
		is_valid_addition = "def(obj, coords) 
			switch(obj.type,
			'civ-tile_farm',	if(get_terrain(coords) = 'plains_grid' and (not played(coords)), 1, 0),
			'civ-tile_mine',	if(get_terrain(coords) in ['hill_grid', 'ore_grid'] and has_food(obj, coords) and (not played(coords)) and ((not find(starve(obj, coords), 'dead', dead.animation = obj.animation)) or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)), 1, 0),
			'civ-tile_settle',	if(get_terrain(coords) != 'ocean_grid' and has_food(obj, coords) and (not played(coords)) and ((not find(starve(obj, coords), 'dead', dead.animation = obj.animation)) or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)), 1, 0),
			'civ-tile_war',		if(get_terrain(coords) != 'ocean_grid' and has_food(obj, coords) and (not find(vars.play, 'tile', tile.gridloc = coords and tile.animation = obj.animation)) and ((not find(starve(obj, coords), 'dead', dead.animation = obj.animation)) or obj.search_adjacent_connected_to_farm(tile_at(coords)[0], tile_at(coords)[1], obj.animation)), 1, 0),
			0)"
		
		#Returns the tile which was played at coords.#
		played = "def(coords) find(vars.play, 'tile', tile.gridloc = coords)"
		
		#Darkens invalid positions for obj to be placed at.#
		draw_blackout = "def(tile) map(range(consts.tiles), 'cX', map(range(consts.tiles), 'cY', 
			if(not is_valid_addition(tile,[cX, cY]) and 'human' = consts.players[vars.turn], 
				spawn('civ_board.no', tile_at([cX,cY])[0], tile_at([cX, cY])[1], facing))))"
		
		#Removes all blacked out tiles.#
		clear_blackout = "map(level.chars, 'obj', if(obj.type = 'civ_board.no', fire_event(obj, 'nix')))"
		
		mouse = "level.player.vars.mouse.pos"
		
		flatten = "def(items) if(items.size = 0, [], items[0] + flatten(items[1:size(items)]))"
		
		war_defeat_tile = "def(tile) [
			set(vars.play, filter(vars.play, 'vp', vp != tile)),
			fire_event(tile, 'nix'),
			fire_event('tiles_in_play_modified'),
			[add_object(war_obj), 
			set(war_obj.midpoint_x, tile.midpoint_x), 
			set(war_obj.midpoint_y, tile.midpoint_y)
			] where war_obj = object('civ_war', x, y, facing), 
			]"
		
		#Takes a coordinate value which is being attacked, and returns the number of war tile objects to be played. See ai_die_turn comment for more details.#
		ai_die_war = "def(coord) (1d5)-1"
	[/properties]
	
	
	
	on_create="[set(draw_area, [0, 0, board_size(), board_size()]),
		
		[set(new_bag.vars.spawner, self),
		add_object(new_bag),
		set(vars.bag, new_bag),
		]where new_bag = object('civ-tile_bag', x + board_size()*2 + right_column_offset, y+((board_size()*5)/3), facing),
		
		if(size(consts.land) = consts.tiles*consts.tiles,
			map(range(size(consts.land)), 'land_index', spawn(self.type + '.' + ltype, lcoord[0], lcoord[1], facing) where lcoord = tile_at([land_index%consts.tiles, land_index/consts.tiles]) where ltype = switch(consts.land[land_index], 0, 'ocean_grid', 1, 'plain_grid', 2, 'hill_grid', 3, 'ore_grid', 'ocean_grid')),
			debug(size(consts.land), ' does not equal ', consts.tiles*consts.tiles, ', failed creating map tiles from land data.')),
			
		spawn('civ_logo', x + board_size()*2 + right_column_offset, y+((board_size()*2)/4), facing),
		
		if(consts.players[0] != 'human' ,[set(vars.turn, -1), fire_event('end_turn')]),
		
		schedule(3, fire_event('find_buttons')),
		
		] where right_column_offset = 125
		where camera = get_object(level, 'logic')"
		
	on_find_buttons="[set(vars.turn_button, bag.turn_button)]"
	
	on_replace = "[
		set(vars.mode, 'replace'),
		debug_console(),
		]"
	
		
	on_lmb_down="[
		map(vars.hand, 'tile', fire_event(tile, 'lmb_down', level.player.vars.mouse)),
		fire_event(vars.turn_button, 'lmb_hold', level.player.vars.mouse),
		fire_event(vars.fight_button, 'lmb_hold', level.player.vars.mouse),
		]"
		
	on_lmb_hold="[
		#debug('tile:', mouse_on_tile())#
		if(ot,
			[set(tmp.old_ot, ot),
			if(tmp.old_ot != ot,
				[set(tmp.tile_highlight, hlt),
				add_object(hlt),
				remove_object(tmp.tile_highlight),
				]where hlt = object('civ_board.tile', tile_at(ot)[0], tile_at(ot)[1], facing)
				)
			],
			[set(tmp.old_ot, 0),
			remove_object(tmp.tile_highlight),
			])
		where ot = mouse_on_tile(),
		
		fire_event(vars.turn_button, 'lmb_hold', level.player.vars.mouse),
		fire_event(vars.fight_button, 'lmb_hold', level.player.vars.mouse),
		]"
		
	on_lmb_up="[
		remove_object(tmp.tile_highlight),
		fire_event(vars.turn_button, 'lmb_up', level.player.vars.mouse),
		fire_event(vars.fight_button, 'lmb_up', level.player.vars.mouse),
		]"
	
	
		
	on_release_tile="
	    if(mouse_on_tile() and consts.players[vars.turn] = 'human',
		[set(arg.midpoint_x, tile_at(mouse_on_tile())[0]),
		 set(arg.midpoint_y, tile_at(mouse_on_tile())[1]),
	     fire_event('release_tile_internal', arg)],
	     fire_event('fail_release_tile', arg))"

	on_release_tile_internal="
	    [#debug(tile_at(mouse_on_tile())),#
		if(mot and is_valid_addition(arg, mouse_on_tile()) and (not arg.type = 'civ-tile_war' and (played(mouse_on_tile()))), #add a tile normally#
			[set(arg.vars.gridloc, mot),
			set(arg.midpoint_x, tile_at(mot)[0]), 
			set(arg.midpoint_y, tile_at(mot)[1]), 
			set(vars.play, vars.play + [arg]), #the crashy bit - Setting arg.midpoint_s before this function avoids a [] crash. Why?#
			fire_event('tiles_in_play_modified'),
			set(vars.bag.vars.on_deal_tile, arg.vars.hand_pos),
			set(arg.animation, consts.tile_types[vars.turn]),
			fire_event(vars.bag, 'deal_p1'),
			if(size(vars.bag.vars.piles[vars.turn]) = 1, debug('Game Over'), fire_event('end_turn')),
			],
			fire_event('fail_release_tile', arg))
			where mot = mouse_on_tile(),
		]"
		
	on_fail_release_tile="
		if((not on_piece(mouse).animation != arg.animation) or arg.type != 'civ-tile_war' or (not on_any_tile(mouse)), 
			fire_event('rehand_tile', arg),
			if(is_valid_addition(arg, mouse_on_tile()),
				[set(arg.midpoint_x, mouse[0]), #WAR!#
				set(arg.midpoint_y, mouse[1]),
				bag.turn_button.set_state('replace'),
				
				war_defeat_tile(on_piece(mouse)),
				fire_event('release_tile_internal', arg),
				
				], 
				fire_event('rehand_tile', arg),)
			)"
		
	on_rehand_tile="arg.go_to(dealt_hand_loc(0,arg.vars.hand_pos))"
	
	
	
	on_tiles_in_play_modified="[add(vars.cache_version, 1),
	     map(vars.play, 'p', fire_event(p, 'calculate_surroundings')),
	     map(vars.play, 'p', fire_event(p, 'calculate_kingdom', context))]"
	
	
	
	on_end_turn="[[schedule(5, [
		switch(consts.players[nt],
		'human', [],
		'ai_die', [fire_event('ai_die_turn')],
		debug('Illegal side', nt),
		),
		#debug(str(tile.animation) + ' ' + str(tile.type) + ' at ' + str(tile.vars.gridloc)) where tile = vars.play[size(vars.play)-1],#
		]),
		set(vars.turn, nt),
		] where nt = (vars.turn+1)%size(consts.players),
		map(vars.play, 'tile', 
			if(not (has_food(tile, tile.vars.gridloc) or tile.type = 'civ-tile_farm'), [
				set(vars.play, filter(vars.play, 'in_play', in_play != tile)), 
				fire_event(tile, 'nix'), 
				[add_object(starve_obj), 
				set(starve_obj.midpoint_x, tile.midpoint_x), 
				set(starve_obj.midpoint_y, tile.midpoint_y)
				] where starve_obj = object('civ_starve', x, y, facing), 
				fire_event('tiles_in_play_modified')
				])
			),
		]"
		
		
	#The code for the die AI. This sequence performs the actions every AI should do. Each
		#AI must fire_event('end_turn') when it is done. (This is the 'next turn' button.)
		#Tiles need to be placed manually (by setting an x, y), and each tile played needs
		#to be added to vars.play. Then, fire_event('tiles_in_play_modified') to update the
		#kingdom cache. A note, vars.bag.extract(vars.turn) returns a list containing the tile
		#object (index 0), which we see, but it also returns a series of instructions (index 1)
		#to remove the object from the tile bag. Make sure to run these instructions, or the
		#bag will never empty.#
	on_ai_die_turn="[
		if(size(validity2d) > 0, [
			set(tile_to_place[0].midpoint_x, tile_at(validity2d[eY][eX])[0]), #set tile pos to grid we chose#
			set(tile_to_place[0].midpoint_y, tile_at(validity2d[eY][eX])[1]),
			set(tile_to_place[0].animation, consts.tile_types[vars.turn]), #set the animation to the current side#
			fire_event('tiles_in_play_modified'),	#update the tile cache#
			set(tile_to_place[0].vars.gridloc, validity2d[eY][eX]), #set the grid location of the tile#
			set(vars.play, vars.play+[tile_to_place[0]]), #add the tile to the list of tiles in play#
			add_object(tile_to_place[0]),
			tile_to_place[1], #actually remove the object from it's bag#
			] where eX = (1d (size(validity2d[eY])))-1 #eX and eY are now valid locations coordinates.#
			where eY = (1d (size(validity2d)))-1,
			fire_event('ai_die_turn'),
			)
		where validity2d = filter(
			map(range(consts.tiles), 'cX', 
				filter(
					map(range(consts.tiles), 'cY', 
						if(is_valid_addition(tile,[cX, cY])
						and (not [cX, cY] in map(vars.play, 'tile', tile.vars.gridloc)
						and ((not find(starve(tile, [cX, cY]), 'dead', dead.animation = tile.animation))
						  or tile.search_adjacent_connected_to_farm(tile_at([cX, cY])[0], tile_at([cX, cY])[1], consts.tile_types[vars.turn])))
						and has_food(tile, [cX, cY]), 
							[cX,cY]
							)
						), 
					'add', add != null)
				),
			'add', add != [])
		where tile = tile_to_place[0],
		
		#debug('ended die`s turn'),# fire_event('end_turn'),
		] where tile_to_place = vars.bag.extract(vars.turn)"
	
	
	on_end_anim="animation('normal')"
	
	[animation]
		id=normal
		image=experimental/civ-tile.png
		x=0
		y=0
		w=16
		h=16
		pad=-1
		frames=1
		duration=6541
		surface_area=all
	[/animation]
	
	
	[object_type]
		id=tile
		hitpoints=2
		zorder=-8
		
		on_create = "[
			#set(red, tint), set(green, tint), set(blue, tint),#
			set(alpha, tint),
			] where tint = 75"
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=11
			y=10
			w=16
			h=16
			pad=-1
			frames=1
			duration=5541
			surface_area=all
		[/animation]
	[/object_type]
	
	
	[object_type]
		id=no
		hitpoints=2
		zorder=9
		
		on_create = "[
			#set(red, tint), set(green, tint), set(blue, tint),#
			set(alpha, tint),
			] where tint = 75"
			
		on_nix="die()"
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=30
			y=10
			w=16
			h=16
			pad=-1
			frames=1
			duration=6541
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=ocean_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=14
			y=85
			w=16
			h=16
			pad=-1
			frames=1
			duration=542
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=plain_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=14
			y=108
			w=16
			h=16
			pad=-1
			frames=1
			duration=543
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=hill_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=14
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=544
			surface_area=all
		[/animation]
	[/object_type]
	
	[object_type]
		id=ore_grid
		hitpoints=2
		zorder=-10
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=33
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=999999999
			surface_area=all
		[/animation]
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=52
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=999999999
			surface_area=all
		[/animation]
		
		[animation]
			id=normal
			image=experimental/civ-stuff.png
			x=71
			y=153
			w=16
			h=16
			pad=-1
			frames=1
			duration=999999999
			surface_area=all
		[/animation]
	[/object_type]
	
[/object_type]
