{
id: "ct-map-marker",
prototype: ["drag_input"],

properties: {
	at: "[midpoint_x, midpoint_y]",
	},

vars: {
	edit: 1,
	#--reference--#
	targeted_by: [],
	targets:	 [],
	},
	
on_mouse_start_drag: "[%PROTO%, set(tmp.origin, [x,y])]",#Store where we started dragging from, might be useful.
	
on_drop: "[
	#Add line between objects…#
	line.stretch(tmp.origin, arg.at),
	add_object(line),
	add(targets, [line]),
	add(arg.vars.targeted_by, [line]),
	set(line.vars.connects, [self, arg]),
	
	#… and reset position.#
	set(vars.reference_anchor, tmp.origin),
	set(vars.anchorPoint, 7),
	fire_event('update_position'),
	] where line = object('{self.type}.line')",
	
#on_dropped_on: "add(targeted_by, [arg])",

animation: [{
	id: "normal",
	image: "experimental/cube trains/custom/ct-map-marker.png",
	rect: [0,0,22,22],
	}],
	
object_type: { #This is a minimal version of frogatto's angled_rope_controller.
	id: "line",
	zorder: -1,
	ignore_collide: true,
	no_compile_image: "props/rope-vertical.png",

	properties: {
		stretch: "def(ptA, ptB) [
			set(self.vars.x_1, ptA[0]),
			set(self.vars.y_1, ptA[1]),
			set(self.vars.x_2, ptB[0]),
			set(self.vars.y_2, ptB[1]),
			fire_event(self, 'redraw'),
			]",
		},

	on_redraw: "[
		debug('Drawn between {[x_1, y_1]} and {[x_2, y_2]}.'),
		set(midpoint_x, (x_2+x_1)/2),
		set(y, (y_2+y_1)/2 - (length/2)),
		set(draw_area, [0, 0, img_w/2, length/2]),
		set(activation_area, [min(x_1,x_2) -200, min(y_1,y_2) -200, abs(x_1-x_2) +200, abs(y_1-y_2) +200]),  #xywh#
		set(rotate,(angle(x_1,y_1,x_2,y_2)-90) )
		]",
		
	animation: [{
		id: "normal",
		image: "props/rope-vertical.png",
		x: 0,
		w: 4,
		y: 0,
		h: 4,
		}],
	}
}