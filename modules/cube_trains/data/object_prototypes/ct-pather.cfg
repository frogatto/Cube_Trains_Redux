{#This prototype grants the object carrying it the findPath function. Note that this isn't cached, because it'll be invalidated when we rotate the game.
properties: {
	on_block: "def(location) transform(location, round(v))",
	
	queryGroupMap: "def(loc_in) if(not find(loc, 'coord', coord < 0) or find(list_subtract(level.player.vars.groupMap['size'], loc), 'coord', coord < 0),
		level.player.vars.groupMap['objs'][loc[0]][loc[1]][loc[2]], 
		['bounds']
		) where loc = list_add(level.player.vars.groupMap['offset'], loc_in)",
	
	getTargets: "def(nowAt, lookingFor, exclude) #nowAt: The location to start the search from. Used for proximity. (not implimented yet) lookingFor is a list of services to search the utils for. First service to match wins, so order matters. Optional 'exclude', a list of locations to exclude from the search.#
		flatten(
			map(lookingFor, 'service', 
				filter(level.player.vars.ped_utils, 'util', service in transform(util.services, v.id) and (not util.vars.location in exclude)) 
			)
		)",
	calculatePath: "def(to, from) #Returns a path to to from optional from.#
		rough
		where rough = debug_fn('START', _calculatePathRough(on_block(to), on_block(if(from, from, self.vars.location)), []))",
		
	_calculatePathRough: "def(to, from, tested) #tested is a list of lists, each list having the form [x,y,z,queried (numpad directions, 0 means all, 5 means center.)]#
		if(debug_fn(['TEST 1 (called with)', {'to':to, 'from':from, 'tested':tested,}], to) = from,
			{'suc':1, 'pth':[from]},
			if(debug_fn(['TEST 2 (newLoc)', newLoc], newLoc), 
				if(debug_fn(['TEST 3 (newloc standable)','ground' in underNewLoc and (not 'ground' in atNewLoc)], 'ground' in underNewLoc and (not 'ground' in atNewLoc)),
					if(restOfPath['suc'], 
						map_merge(	{'pth':[from]},
									debug_fn(['YAY', restOfPath], restOfPath)
									),
						_calculatePathRough(to, from, tested + restOfPath['tst'] + [newLoc] + [from])
						),
					if('bounds' in atNewLoc, 
						{'suc':0, 'tst':[from]},
						_calculatePathRough(to, from, tested + restOfPath['tst'] + [newLoc] + [from])
						)
					) where restOfPath = 
						if('bounds' in atNewLoc, 
							{'suc':0, 'tst':[from]},
							_calculatePathRough(to, newLoc, tested + [newLoc] + [from])
							)
				where atNewLoc = queryGroupMap(newLoc)
				where underNewLoc = queryGroupMap(list_add([0,0,-1], newLoc)) #hehehe#,
				{'suc':0, 'tst':[from]})
			where newLoc = find(idealNewLoc, 'inl', not inl in tested)
			where idealNewLoc = [
				if((vector[0] > vector[1]) where vector = transform(list_subtract(to, from), abs(v)), #1#
				list_add(from, [if(to[0] > from[0], 1, -1),0,0]), 
				list_add(from, [0, if(to[1] > from[1], 1, -1),0])
				),
				if((vector[0] < vector[1]) where vector = transform(list_subtract(to, from), abs(v)), #2#
				list_add(from, [if(to[0] > from[0], 1, -1),0,0]), 
				list_add(from, [0, if(to[1] > from[1], 1, -1),0])
				),
				if((vector[0] < vector[1]) where vector = transform(list_subtract(to, from), abs(v)), #2#
				list_add(from, [if(to[0] < from[0], 1, -1),0,0]), 
				list_add(from, [0, if(to[1] < from[1], 1, -1),0])
				),
				if((vector[0] > vector[1]) where vector = transform(list_subtract(to, from), abs(v)), #4#
				list_add(from, [if(to[0] < from[0], 1, -1),0,0]), 
				list_add(from, [0, if(to[1] < from[1], 1, -1),0])
				)]
			)
		",
	},
}